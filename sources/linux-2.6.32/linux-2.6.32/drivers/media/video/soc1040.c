/*
 * OmniVision SOC1040 Camera Driver
 *
 * Copyright (C) 2011 NVIDIA Corporation
 *
 * Based on ov9640 camera driver.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#include <linux/init.h>
#include <linux/module.h>
#include <linux/i2c.h>
#include <linux/slab.h>
#include <linux/delay.h>

#include <media/v4l2-chip-ident.h>
#include <media/v4l2-device.h>
#include "soc1040_regs.h"
#include <media/soc1040.h>

#define to_soc1040_sensor(sd)	container_of(sd, struct soc1040_priv, subdev)
#define I2C_M_WR 0

/* supported resolutions */
#define RES_1280x720_W			1280
#define RES_1280x720_H			720

struct soc1040_priv {
	struct v4l2_subdev		subdev;
	struct media_pad 		pad;
	struct soc1040_platform_data     *pdata;
	struct v4l2_mbus_framefmt	format;
	int				ident;
	u16				model;
	u8				revision;
	u8				manid;
	u8				smiaver;

	bool				flag_vflip;
	bool				flag_hflip;

	int 				power_count;
};

static const struct soc1040_reg soc1040_defaults[] = {
{0x098E, 0x0000, I2C_16BIT},  	// LOGICAL_ADDRESS_ACCESS
{0xC97E, 0x01, I2C_8BIT}, 	// CAM_SYSCTL_PLL_ENABLE
{0xC980, 0x0120, I2C_16BIT},  	// CAM_SYSCTL_PLL_DIVIDER_M_N
{0xC982, 0x0700, I2C_16BIT},  	// CAM_SYSCTL_PLL_DIVIDER_P
{0x098E, 0x0000, I2C_16BIT},  	// LOGICAL_ADDRESS_ACCESS
{0xC800, 0x007C, I2C_16BIT},  	// CAM_SENSOR_CFG_Y_ADDR_START
{0xC802, 0x0004, I2C_16BIT},  	// CAM_SENSOR_CFG_X_ADDR_START
{0xC804, 0x0353, I2C_16BIT},  	// CAM_SENSOR_CFG_Y_ADDR_END
{0xC806, 0x050B, I2C_16BIT},  	// CAM_SENSOR_CFG_X_ADDR_END
{0xC808, 0x02DC, I2C_16BIT}, 	// CAM_SENSOR_CFG_PIXCLK_UPPER
{0xC80A, 0x6C00, I2C_16BIT},  	// CAM_SENSOR_CFG_PIXCLK_LOWER
{0xC80C, 0x0001, I2C_16BIT},  	// CAM_SENSOR_CFG_ROW_SPEED
{0xC80E, 0x00DB, I2C_16BIT},  	// CAM_SENSOR_CFG_FINE_INTEG_TIME_MIN
{0xC810, 0x05BD, I2C_16BIT},  	// CAM_SENSOR_CFG_FINE_INTEG_TIME_MAX
{0xC812, 0x03EE, I2C_16BIT},  	// CAM_SENSOR_CFG_FRAME_LENGTH_LINES
{0xC814, 0x0640, I2C_16BIT},  	// CAM_SENSOR_CFG_LINE_LENGTH_PCK
{0xC816, 0x0060, I2C_16BIT},  	// CAM_SENSOR_CFG_FINE_CORRECTION
{0xC818, 0x02D3, I2C_16BIT},  	// CAM_SENSOR_CFG_CPIPE_LAST_ROW
{0xC826, 0x0020, I2C_16BIT},  	// CAM_SENSOR_CFG_REG_0_DATA
{0xC834, 0x0000, I2C_16BIT},  	// CAM_SENSOR_CONTROL_READ_MODE
{0xC854, 0x0000, I2C_16BIT},  	// CAM_CROP_WINDOW_XOFFSET
{0xC856, 0x0000, I2C_16BIT},  	// CAM_CROP_WINDOW_YOFFSET
{0xC858, 0x0500, I2C_16BIT},  	// CAM_CROP_WINDOW_WIDTH
{0xC85A, 0x02D0, I2C_16BIT},  	// CAM_CROP_WINDOW_HEIGHT
{0xC85C, 0x03, I2C_8BIT}, 	// CAM_CROP_CROPMODE
{0xC868, 0x0500, I2C_16BIT},  	// CAM_OUTPUT_WIDTH
{0xC86A, 0x02D0, I2C_16BIT},  	// CAM_OUTPUT_HEIGHT
{0xC878, 0x0C, I2C_8BIT}, 	// CAM_AET_AEMODE
{0xC88C, 0x1E00, I2C_16BIT},  	// CAM_AET_MAX_FRAME_RATE
{0xC88E, 0x1E00, I2C_16BIT},  	// CAM_AET_MIN_FRAME_RATE
{0xC914, 0x0000, I2C_16BIT},  	// CAM_STAT_AWB_CLIP_WINDOW_XSTART
{0xC916, 0x0000, I2C_16BIT},  	// CAM_STAT_AWB_CLIP_WINDOW_YSTART
{0xC918, 0x04FF, I2C_16BIT},  	// CAM_STAT_AWB_CLIP_WINDOW_XEND
{0xC91A, 0x02CF, I2C_16BIT},  	// CAM_STAT_AWB_CLIP_WINDOW_YEND
{0xC91C, 0x0000, I2C_16BIT},  	// CAM_STAT_AE_INITIAL_WINDOW_XSTART
{0xC91E, 0x0000, I2C_16BIT},  	// CAM_STAT_AE_INITIAL_WINDOW_YSTART
{0xC920, 0x00FF, I2C_16BIT},  	// CAM_STAT_AE_INITIAL_WINDOW_XEND
{0xC922, 0x008F, I2C_16BIT},  	// CAM_STAT_AE_INITIAL_WINDOW_YEND
{0xA407, 0x00, I2C_8BIT}, 	// AE_RULE_AE_WEIGHT_TABLE_0_0
{0xA408, 0x00, I2C_8BIT}, 	// AE_RULE_AE_WEIGHT_TABLE_0_1
{0xA409, 0x00, I2C_8BIT}, 	// AE_RULE_AE_WEIGHT_TABLE_0_2
{0xA40A, 0x00, I2C_8BIT}, 	// AE_RULE_AE_WEIGHT_TABLE_0_3
{0xA40B, 0x00, I2C_8BIT}, 	// AE_RULE_AE_WEIGHT_TABLE_0_4
{0xA40C, 0x00, I2C_8BIT}, 	// AE_RULE_AE_WEIGHT_TABLE_1_0
{0xA40D, 0x32, I2C_8BIT}, 	// AE_RULE_AE_WEIGHT_TABLE_1_1
{0xA40F, 0x32, I2C_8BIT}, 	// AE_RULE_AE_WEIGHT_TABLE_1_3
{0xA410, 0x00, I2C_8BIT}, 	// AE_RULE_AE_WEIGHT_TABLE_1_4
{0xA411, 0x19, I2C_8BIT}, 	// AE_RULE_AE_WEIGHT_TABLE_2_0
{0xA415, 0x19, I2C_8BIT}, 	// AE_RULE_AE_WEIGHT_TABLE_2_4
{0xA416, 0x00, I2C_8BIT}, 	// AE_RULE_AE_WEIGHT_TABLE_3_0
{0xA417, 0x32, I2C_8BIT}, 	// AE_RULE_AE_WEIGHT_TABLE_3_1
{0xA419, 0x32, I2C_8BIT}, 	// AE_RULE_AE_WEIGHT_TABLE_3_3
{0xA41A, 0x00, I2C_8BIT}, 	// AE_RULE_AE_WEIGHT_TABLE_3_4
{0xA41B, 0x00, I2C_8BIT}, 	// AE_RULE_AE_WEIGHT_TABLE_4_0
{0xA41C, 0x19, I2C_8BIT}, 	// AE_RULE_AE_WEIGHT_TABLE_4_1
{0xA41E, 0x19, I2C_8BIT}, 	// AE_RULE_AE_WEIGHT_TABLE_4_3
{0xA41F, 0x00, I2C_8BIT}, 	// AE_RULE_AE_WEIGHT_TABLE_4_4
{0x316A, 0x8270, I2C_16BIT},  	// RESERVED_CORE_316A
{0x316C, 0x8270, I2C_16BIT},  	// RESERVED_CORE_316C
{0x3ED0, 0x2305, I2C_16BIT},  	// RESERVED_CORE_3ED0
{0x3ED2, 0x77CF, I2C_16BIT},  	// RESERVED_CORE_3ED2
{0x316E, 0x8202, I2C_16BIT},  	// RESERVED_CORE_316E
{0x3180, 0x87FF, I2C_16BIT},  	// RESERVED_CORE_3180
{0x30D4, 0x6080, I2C_16BIT},  	// RESERVED_CORE_30D4
{0xA802, 0x0008, I2C_16BIT},  	// RESERVED_AE_TRACK_02
{0x3E14, 0xFF39, I2C_16BIT},  	// RESERVED_CORE_3E14
{0x301A, 0x0230, I2C_16BIT},  	// RESET_REGISTER
{0x3C40, 0x7830, I2C_16BIT}, 		//MIPI_NON_CONTINUOUS_MODE
{0x0982, 0x0001, I2C_16BIT},  	// ACCESS_CTL_STAT
{0x098A, 0x5000, I2C_16BIT},  	// PHYSICAL_ADDRESS_ACCESS
{0xD000, 0x70CF, I2C_16BIT}, 
{0xD002, 0xFFFF, I2C_16BIT}, 
{0xD004, 0xC5D4, I2C_16BIT}, 
{0xD006, 0x903A, I2C_16BIT}, 
{0xD008, 0x2144, I2C_16BIT}, 
{0xD00A, 0x0C00, I2C_16BIT}, 
{0xD00C, 0x2186, I2C_16BIT}, 
{0xD00E, 0x0FF3, I2C_16BIT}, 
{0xD010, 0xB844, I2C_16BIT}, 
{0xD012, 0xB948, I2C_16BIT}, 
{0xD014, 0xE082, I2C_16BIT}, 
{0xD016, 0x20CC, I2C_16BIT}, 
{0xD018, 0x80E2, I2C_16BIT}, 
{0xD01A, 0x21CC, I2C_16BIT}, 
{0xD01C, 0x80A2, I2C_16BIT}, 
{0xD01E, 0x21CC, I2C_16BIT}, 
{0xD020, 0x80E2, I2C_16BIT}, 
{0xD022, 0xF404, I2C_16BIT}, 
{0xD024, 0xD801, I2C_16BIT}, 
{0xD026, 0xF003, I2C_16BIT}, 
{0xD028, 0xD800, I2C_16BIT}, 
{0xD02A, 0x7EE0, I2C_16BIT}, 
{0xD02C, 0xC0F1, I2C_16BIT}, 
{0xD02E, 0x08BA, I2C_16BIT}, 
{0xD030, 0x0600, I2C_16BIT}, 
{0xD032, 0xC1A1, I2C_16BIT}, 
{0xD034, 0x76CF, I2C_16BIT}, 
{0xD036, 0xFFFF, I2C_16BIT}, 
{0xD038, 0xC130, I2C_16BIT}, 
{0xD03A, 0x6E04, I2C_16BIT}, 
{0xD03C, 0xC040, I2C_16BIT}, 
{0xD03E, 0x71CF, I2C_16BIT}, 
{0xD040, 0xFFFF, I2C_16BIT}, 
{0xD042, 0xC790, I2C_16BIT}, 
{0xD044, 0x8103, I2C_16BIT}, 
{0xD046, 0x77CF, I2C_16BIT}, 
{0xD048, 0xFFFF, I2C_16BIT}, 
{0xD04A, 0xC7C0, I2C_16BIT}, 
{0xD04C, 0xE001, I2C_16BIT}, 
{0xD04E, 0xA103, I2C_16BIT}, 
{0xD050, 0xD800, I2C_16BIT}, 
{0xD052, 0x0C6A, I2C_16BIT}, 
{0xD054, 0x04E0, I2C_16BIT}, 
{0xD056, 0xB89E, I2C_16BIT}, 
{0xD058, 0x7508, I2C_16BIT}, 
{0xD05A, 0x8E1C, I2C_16BIT}, 
{0xD05C, 0x0809, I2C_16BIT}, 
{0xD05E, 0x0191, I2C_16BIT}, 
{0xD060, 0xD801, I2C_16BIT}, 
{0xD062, 0xAE1D, I2C_16BIT}, 
{0xD064, 0xE580, I2C_16BIT}, 
{0xD066, 0x20CA, I2C_16BIT}, 
{0xD068, 0x0022, I2C_16BIT}, 
{0xD06A, 0x20CF, I2C_16BIT}, 
{0xD06C, 0x0522, I2C_16BIT}, 
{0xD06E, 0x0C5C, I2C_16BIT}, 
{0xD070, 0x04E2, I2C_16BIT}, 
{0xD072, 0x21CA, I2C_16BIT}, 
{0xD074, 0x0062, I2C_16BIT}, 
{0xD076, 0xE580, I2C_16BIT}, 
{0xD078, 0xD901, I2C_16BIT}, 
{0xD07A, 0x79C0, I2C_16BIT}, 
{0xD07C, 0xD800, I2C_16BIT}, 
{0xD07E, 0x0BE6, I2C_16BIT}, 
{0xD080, 0x04E0, I2C_16BIT}, 
{0xD082, 0xB89E, I2C_16BIT}, 
{0xD084, 0x70CF, I2C_16BIT}, 
{0xD086, 0xFFFF, I2C_16BIT}, 
{0xD088, 0xC8D4, I2C_16BIT}, 
{0xD08A, 0x9002, I2C_16BIT}, 
{0xD08C, 0x0857, I2C_16BIT}, 
{0xD08E, 0x025E, I2C_16BIT}, 
{0xD090, 0xFFDC, I2C_16BIT}, 
{0xD092, 0xE080, I2C_16BIT}, 
{0xD094, 0x25CC, I2C_16BIT}, 
{0xD096, 0x9022, I2C_16BIT}, 
{0xD098, 0xF225, I2C_16BIT}, 
{0xD09A, 0x1700, I2C_16BIT}, 
{0xD09C, 0x108A, I2C_16BIT}, 
{0xD09E, 0x73CF, I2C_16BIT}, 
{0xD0A0, 0xFF00, I2C_16BIT}, 
{0xD0A2, 0x3174, I2C_16BIT}, 
{0xD0A4, 0x9307, I2C_16BIT}, 
{0xD0A6, 0x2A04, I2C_16BIT}, 
{0xD0A8, 0x103E, I2C_16BIT}, 
{0xD0AA, 0x9328, I2C_16BIT}, 
{0xD0AC, 0x2942, I2C_16BIT}, 
{0xD0AE, 0x7140, I2C_16BIT}, 
{0xD0B0, 0x2A04, I2C_16BIT}, 
{0xD0B2, 0x107E, I2C_16BIT}, 
{0xD0B4, 0x9349, I2C_16BIT}, 
{0xD0B6, 0x2942, I2C_16BIT}, 
{0xD0B8, 0x7141, I2C_16BIT}, 
{0xD0BA, 0x2A04, I2C_16BIT}, 
{0xD0BC, 0x10BE, I2C_16BIT}, 
{0xD0BE, 0x934A, I2C_16BIT}, 
{0xD0C0, 0x2942, I2C_16BIT}, 
{0xD0C2, 0x714B, I2C_16BIT}, 
{0xD0C4, 0x2A04, I2C_16BIT}, 
{0xD0C6, 0x10BE, I2C_16BIT}, 
{0xD0C8, 0x130C, I2C_16BIT}, 
{0xD0CA, 0x010A, I2C_16BIT}, 
{0xD0CC, 0x2942, I2C_16BIT}, 
{0xD0CE, 0x7142, I2C_16BIT}, 
{0xD0D0, 0x2250, I2C_16BIT}, 
{0xD0D2, 0x13CA, I2C_16BIT}, 
{0xD0D4, 0x1B0C, I2C_16BIT}, 
{0xD0D6, 0x0284, I2C_16BIT}, 
{0xD0D8, 0xB307, I2C_16BIT}, 
{0xD0DA, 0xB328, I2C_16BIT}, 
{0xD0DC, 0x1B12, I2C_16BIT}, 
{0xD0DE, 0x02C4, I2C_16BIT}, 
{0xD0E0, 0xB34A, I2C_16BIT}, 
{0xD0E2, 0xED88, I2C_16BIT}, 
{0xD0E4, 0x71CF, I2C_16BIT}, 
{0xD0E6, 0xFF00, I2C_16BIT}, 
{0xD0E8, 0x3174, I2C_16BIT}, 
{0xD0EA, 0x9106, I2C_16BIT}, 
{0xD0EC, 0xB88F, I2C_16BIT}, 
{0xD0EE, 0xB106, I2C_16BIT}, 
{0xD0F0, 0x210A, I2C_16BIT}, 
{0xD0F2, 0x8340, I2C_16BIT}, 
{0xD0F4, 0xC000, I2C_16BIT}, 
{0xD0F6, 0x21CA, I2C_16BIT}, 
{0xD0F8, 0x0062, I2C_16BIT}, 
{0xD0FA, 0x20F0, I2C_16BIT}, 
{0xD0FC, 0x0040, I2C_16BIT}, 
{0xD0FE, 0x0B02, I2C_16BIT}, 
{0xD100, 0x0320, I2C_16BIT}, 
{0xD102, 0xD901, I2C_16BIT}, 
{0xD104, 0x07F1, I2C_16BIT}, 
{0xD106, 0x05E0, I2C_16BIT}, 
{0xD108, 0xC0A1, I2C_16BIT}, 
{0xD10A, 0x78E0, I2C_16BIT}, 
{0xD10C, 0xC0F1, I2C_16BIT}, 
{0xD10E, 0x71CF, I2C_16BIT}, 
{0xD110, 0xFFFF, I2C_16BIT}, 
{0xD112, 0xC7C0, I2C_16BIT}, 
{0xD114, 0xD840, I2C_16BIT}, 
{0xD116, 0xA900, I2C_16BIT}, 
{0xD118, 0x71CF, I2C_16BIT}, 
{0xD11A, 0xFFFF, I2C_16BIT}, 
{0xD11C, 0xD02C, I2C_16BIT}, 
{0xD11E, 0xD81E, I2C_16BIT}, 
{0xD120, 0x0A5A, I2C_16BIT}, 
{0xD122, 0x04E0, I2C_16BIT}, 
{0xD124, 0xDA00, I2C_16BIT}, 
{0xD126, 0xD800, I2C_16BIT}, 
{0xD128, 0xC0D1, I2C_16BIT}, 
{0xD12A, 0x7EE0, I2C_16BIT}, 
{0x098E, 0x0000, I2C_16BIT},  	// LOGICAL_ADDRESS_ACCESS
{0xE000, 0x010C, I2C_16BIT},  	// PATCHLDR_LOADER_ADDRESS
{0xE002, 0x0202, I2C_16BIT},  	// PATCHLDR_PATCH_ID
{0xE004, 0x4103, I2C_16BIT}, 	// PATCHLDR_FIRMWARE_ID_UPPER
{0xE006, 0x0202, I2C_16BIT},  	// PATCHLDR_FIRMWARE_ID_LOWER
{0x0080, 0xFFF0, I2C_16BIT},  	// COMMAND_REGISTER
{0x0080, 0xFFF1, I2C_16BIT},  	// COMMAND_REGISTER
{0x0982, 0x0001, I2C_16BIT},  	// ACCESS_CTL_STAT
{0x098A, 0x512C, I2C_16BIT},  	// PHYSICAL_ADDRESS_ACCESS
{0xD12C, 0x70CF, I2C_16BIT}, 
{0xD12E, 0xFFFF, I2C_16BIT}, 
{0xD130, 0xC5D4, I2C_16BIT}, 
{0xD132, 0x903A, I2C_16BIT}, 
{0xD134, 0x2144, I2C_16BIT}, 
{0xD136, 0x0C00, I2C_16BIT}, 
{0xD138, 0x2186, I2C_16BIT}, 
{0xD13A, 0x0FF3, I2C_16BIT}, 
{0xD13C, 0xB844, I2C_16BIT}, 
{0xD13E, 0x262F, I2C_16BIT}, 
{0xD140, 0xF008, I2C_16BIT}, 
{0xD142, 0xB948, I2C_16BIT}, 
{0xD144, 0x21CC, I2C_16BIT}, 
{0xD146, 0x8021, I2C_16BIT}, 
{0xD148, 0xD801, I2C_16BIT}, 
{0xD14A, 0xF203, I2C_16BIT}, 
{0xD14C, 0xD800, I2C_16BIT}, 
{0xD14E, 0x7EE0, I2C_16BIT}, 
{0xD150, 0xC0F1, I2C_16BIT}, 
{0xD152, 0x71CF, I2C_16BIT}, 
{0xD154, 0xFFFF, I2C_16BIT}, 
{0xD156, 0xC610, I2C_16BIT}, 
{0xD158, 0x910E, I2C_16BIT}, 
{0xD15A, 0x208C, I2C_16BIT}, 
{0xD15C, 0x8014, I2C_16BIT}, 
{0xD15E, 0xF418, I2C_16BIT}, 
{0xD160, 0x910F, I2C_16BIT}, 
{0xD162, 0x208C, I2C_16BIT}, 
{0xD164, 0x800F, I2C_16BIT}, 
{0xD166, 0xF414, I2C_16BIT}, 
{0xD168, 0x9116, I2C_16BIT}, 
{0xD16A, 0x208C, I2C_16BIT}, 
{0xD16C, 0x800A, I2C_16BIT}, 
{0xD16E, 0xF410, I2C_16BIT}, 
{0xD170, 0x9117, I2C_16BIT}, 
{0xD172, 0x208C, I2C_16BIT}, 
{0xD174, 0x8807, I2C_16BIT}, 
{0xD176, 0xF40C, I2C_16BIT}, 
{0xD178, 0x9118, I2C_16BIT}, 
{0xD17A, 0x2086, I2C_16BIT}, 
{0xD17C, 0x0FF3, I2C_16BIT}, 
{0xD17E, 0xB848, I2C_16BIT}, 
{0xD180, 0x080D, I2C_16BIT}, 
{0xD182, 0x0090, I2C_16BIT}, 
{0xD184, 0xFFEA, I2C_16BIT}, 
{0xD186, 0xE081, I2C_16BIT}, 
{0xD188, 0xD801, I2C_16BIT}, 
{0xD18A, 0xF203, I2C_16BIT}, 
{0xD18C, 0xD800, I2C_16BIT}, 
{0xD18E, 0xC0D1, I2C_16BIT}, 
{0xD190, 0x7EE0, I2C_16BIT}, 
{0xD192, 0x78E0, I2C_16BIT}, 
{0xD194, 0xC0F1, I2C_16BIT}, 
{0xD196, 0x71CF, I2C_16BIT}, 
{0xD198, 0xFFFF, I2C_16BIT}, 
{0xD19A, 0xC610, I2C_16BIT}, 
{0xD19C, 0x910E, I2C_16BIT}, 
{0xD19E, 0x208C, I2C_16BIT}, 
{0xD1A0, 0x800A, I2C_16BIT}, 
{0xD1A2, 0xF418, I2C_16BIT}, 
{0xD1A4, 0x910F, I2C_16BIT}, 
{0xD1A6, 0x208C, I2C_16BIT}, 
{0xD1A8, 0x8807, I2C_16BIT}, 
{0xD1AA, 0xF414, I2C_16BIT}, 
{0xD1AC, 0x9116, I2C_16BIT}, 
{0xD1AE, 0x208C, I2C_16BIT}, 
{0xD1B0, 0x800A, I2C_16BIT}, 
{0xD1B2, 0xF410, I2C_16BIT}, 
{0xD1B4, 0x9117, I2C_16BIT}, 
{0xD1B6, 0x208C, I2C_16BIT}, 
{0xD1B8, 0x8807, I2C_16BIT}, 
{0xD1BA, 0xF40C, I2C_16BIT}, 
{0xD1BC, 0x9118, I2C_16BIT}, 
{0xD1BE, 0x2086, I2C_16BIT}, 
{0xD1C0, 0x0FF3, I2C_16BIT}, 
{0xD1C2, 0xB848, I2C_16BIT}, 
{0xD1C4, 0x080D, I2C_16BIT}, 
{0xD1C6, 0x0090, I2C_16BIT}, 
{0xD1C8, 0xFFD9, I2C_16BIT}, 
{0xD1CA, 0xE080, I2C_16BIT}, 
{0xD1CC, 0xD801, I2C_16BIT}, 
{0xD1CE, 0xF203, I2C_16BIT}, 
{0xD1D0, 0xD800, I2C_16BIT}, 
{0xD1D2, 0xF1DF, I2C_16BIT}, 
{0xD1D4, 0x9040, I2C_16BIT}, 
{0xD1D6, 0x71CF, I2C_16BIT}, 
{0xD1D8, 0xFFFF, I2C_16BIT}, 
{0xD1DA, 0xC5D4, I2C_16BIT}, 
{0xD1DC, 0xB15A, I2C_16BIT}, 
{0xD1DE, 0x9041, I2C_16BIT}, 
{0xD1E0, 0x73CF, I2C_16BIT}, 
{0xD1E2, 0xFFFF, I2C_16BIT}, 
{0xD1E4, 0xC7D0, I2C_16BIT}, 
{0xD1E6, 0xB140, I2C_16BIT}, 
{0xD1E8, 0x9042, I2C_16BIT}, 
{0xD1EA, 0xB141, I2C_16BIT}, 
{0xD1EC, 0x9043, I2C_16BIT}, 
{0xD1EE, 0xB142, I2C_16BIT}, 
{0xD1F0, 0x9044, I2C_16BIT}, 
{0xD1F2, 0xB143, I2C_16BIT}, 
{0xD1F4, 0x9045, I2C_16BIT}, 
{0xD1F6, 0xB147, I2C_16BIT}, 
{0xD1F8, 0x9046, I2C_16BIT}, 
{0xD1FA, 0xB148, I2C_16BIT}, 
{0xD1FC, 0x9047, I2C_16BIT}, 
{0xD1FE, 0xB14B, I2C_16BIT}, 
{0xD200, 0x9048, I2C_16BIT}, 
{0xD202, 0xB14C, I2C_16BIT}, 
{0xD204, 0x9049, I2C_16BIT}, 
{0xD206, 0x1958, I2C_16BIT}, 
{0xD208, 0x0084, I2C_16BIT}, 
{0xD20A, 0x904A, I2C_16BIT}, 
{0xD20C, 0x195A, I2C_16BIT}, 
{0xD20E, 0x0084, I2C_16BIT}, 
{0xD210, 0x8856, I2C_16BIT}, 
{0xD212, 0x1B36, I2C_16BIT}, 
{0xD214, 0x8082, I2C_16BIT}, 
{0xD216, 0x8857, I2C_16BIT}, 
{0xD218, 0x1B37, I2C_16BIT}, 
{0xD21A, 0x8082, I2C_16BIT}, 
{0xD21C, 0x904C, I2C_16BIT}, 
{0xD21E, 0x19A7, I2C_16BIT}, 
{0xD220, 0x009C, I2C_16BIT}, 
{0xD222, 0x881A, I2C_16BIT}, 
{0xD224, 0x7FE0, I2C_16BIT}, 
{0xD226, 0x1B54, I2C_16BIT}, 
{0xD228, 0x8002, I2C_16BIT}, 
{0xD22A, 0x78E0, I2C_16BIT}, 
{0xD22C, 0x71CF, I2C_16BIT}, 
{0xD22E, 0xFFFF, I2C_16BIT}, 
{0xD230, 0xC350, I2C_16BIT}, 
{0xD232, 0xD828, I2C_16BIT}, 
{0xD234, 0xA90B, I2C_16BIT}, 
{0xD236, 0x8100, I2C_16BIT}, 
{0xD238, 0x01C5, I2C_16BIT}, 
{0xD23A, 0x0320, I2C_16BIT}, 
{0xD23C, 0xD900, I2C_16BIT}, 
{0xD23E, 0x78E0, I2C_16BIT}, 
{0xD240, 0x220A, I2C_16BIT}, 
{0xD242, 0x1F80, I2C_16BIT}, 
{0xD244, 0xFFFF, I2C_16BIT}, 
{0xD246, 0xD4E0, I2C_16BIT}, 
{0xD248, 0xC0F1, I2C_16BIT}, 
{0xD24A, 0x0811, I2C_16BIT}, 
{0xD24C, 0x0051, I2C_16BIT}, 
{0xD24E, 0x2240, I2C_16BIT}, 
{0xD250, 0x1200, I2C_16BIT}, 
{0xD252, 0xFFE1, I2C_16BIT}, 
{0xD254, 0xD801, I2C_16BIT}, 
{0xD256, 0xF006, I2C_16BIT}, 
{0xD258, 0x2240, I2C_16BIT}, 
{0xD25A, 0x1900, I2C_16BIT}, 
{0xD25C, 0xFFDE, I2C_16BIT}, 
{0xD25E, 0xD802, I2C_16BIT}, 
{0xD260, 0x1A05, I2C_16BIT}, 
{0xD262, 0x1002, I2C_16BIT}, 
{0xD264, 0xFFF2, I2C_16BIT}, 
{0xD266, 0xF195, I2C_16BIT}, 
{0xD268, 0xC0F1, I2C_16BIT}, 
{0xD26A, 0x0E7E, I2C_16BIT}, 
{0xD26C, 0x05C0, I2C_16BIT}, 
{0xD26E, 0x75CF, I2C_16BIT}, 
{0xD270, 0xFFFF, I2C_16BIT}, 
{0xD272, 0xC84C, I2C_16BIT}, 
{0xD274, 0x9502, I2C_16BIT}, 
{0xD276, 0x77CF, I2C_16BIT}, 
{0xD278, 0xFFFF, I2C_16BIT}, 
{0xD27A, 0xC344, I2C_16BIT}, 
{0xD27C, 0x2044, I2C_16BIT}, 
{0xD27E, 0x008E, I2C_16BIT}, 
{0xD280, 0xB8A1, I2C_16BIT}, 
{0xD282, 0x0926, I2C_16BIT}, 
{0xD284, 0x03E0, I2C_16BIT}, 
{0xD286, 0xB502, I2C_16BIT}, 
{0xD288, 0x9502, I2C_16BIT}, 
{0xD28A, 0x952E, I2C_16BIT}, 
{0xD28C, 0x7E05, I2C_16BIT}, 
{0xD28E, 0xB5C2, I2C_16BIT}, 
{0xD290, 0x70CF, I2C_16BIT}, 
{0xD292, 0xFFFF, I2C_16BIT}, 
{0xD294, 0xC610, I2C_16BIT}, 
{0xD296, 0x099A, I2C_16BIT}, 
{0xD298, 0x04A0, I2C_16BIT}, 
{0xD29A, 0xB026, I2C_16BIT}, 
{0xD29C, 0x0E02, I2C_16BIT}, 
{0xD29E, 0x0560, I2C_16BIT}, 
{0xD2A0, 0xDE00, I2C_16BIT}, 
{0xD2A2, 0x0A12, I2C_16BIT}, 
{0xD2A4, 0x0320, I2C_16BIT}, 
{0xD2A6, 0xB7C4, I2C_16BIT}, 
{0xD2A8, 0x0B36, I2C_16BIT}, 
{0xD2AA, 0x03A0, I2C_16BIT}, 
{0xD2AC, 0x70C9, I2C_16BIT}, 
{0xD2AE, 0x9502, I2C_16BIT}, 
{0xD2B0, 0x7608, I2C_16BIT}, 
{0xD2B2, 0xB8A8, I2C_16BIT}, 
{0xD2B4, 0xB502, I2C_16BIT}, 
{0xD2B6, 0x70CF, I2C_16BIT}, 
{0xD2B8, 0x0000, I2C_16BIT}, 
{0xD2BA, 0x5536, I2C_16BIT}, 
{0xD2BC, 0x7860, I2C_16BIT}, 
{0xD2BE, 0x2686, I2C_16BIT}, 
{0xD2C0, 0x1FFB, I2C_16BIT}, 
{0xD2C2, 0x9502, I2C_16BIT}, 
{0xD2C4, 0x78C5, I2C_16BIT}, 
{0xD2C6, 0x0631, I2C_16BIT}, 
{0xD2C8, 0x05E0, I2C_16BIT}, 
{0xD2CA, 0xB502, I2C_16BIT}, 
{0xD2CC, 0x72CF, I2C_16BIT}, 
{0xD2CE, 0xFFFF, I2C_16BIT}, 
{0xD2D0, 0xC5D4, I2C_16BIT}, 
{0xD2D2, 0x923A, I2C_16BIT}, 
{0xD2D4, 0x73CF, I2C_16BIT}, 
{0xD2D6, 0xFFFF, I2C_16BIT}, 
{0xD2D8, 0xC7D0, I2C_16BIT}, 
{0xD2DA, 0xB020, I2C_16BIT}, 
{0xD2DC, 0x9220, I2C_16BIT}, 
{0xD2DE, 0xB021, I2C_16BIT}, 
{0xD2E0, 0x9221, I2C_16BIT}, 
{0xD2E2, 0xB022, I2C_16BIT}, 
{0xD2E4, 0x9222, I2C_16BIT}, 
{0xD2E6, 0xB023, I2C_16BIT}, 
{0xD2E8, 0x9223, I2C_16BIT}, 
{0xD2EA, 0xB024, I2C_16BIT}, 
{0xD2EC, 0x9227, I2C_16BIT}, 
{0xD2EE, 0xB025, I2C_16BIT}, 
{0xD2F0, 0x9228, I2C_16BIT}, 
{0xD2F2, 0xB026, I2C_16BIT}, 
{0xD2F4, 0x922B, I2C_16BIT}, 
{0xD2F6, 0xB027, I2C_16BIT}, 
{0xD2F8, 0x922C, I2C_16BIT}, 
{0xD2FA, 0xB028, I2C_16BIT}, 
{0xD2FC, 0x1258, I2C_16BIT}, 
{0xD2FE, 0x0101, I2C_16BIT}, 
{0xD300, 0xB029, I2C_16BIT}, 
{0xD302, 0x125A, I2C_16BIT}, 
{0xD304, 0x0101, I2C_16BIT}, 
{0xD306, 0xB02A, I2C_16BIT}, 
{0xD308, 0x1336, I2C_16BIT}, 
{0xD30A, 0x8081, I2C_16BIT}, 
{0xD30C, 0xA836, I2C_16BIT}, 
{0xD30E, 0x1337, I2C_16BIT}, 
{0xD310, 0x8081, I2C_16BIT}, 
{0xD312, 0xA837, I2C_16BIT}, 
{0xD314, 0x12A7, I2C_16BIT}, 
{0xD316, 0x0701, I2C_16BIT}, 
{0xD318, 0xB02C, I2C_16BIT}, 
{0xD31A, 0x1354, I2C_16BIT}, 
{0xD31C, 0x8081, I2C_16BIT}, 
{0xD31E, 0x7FE0, I2C_16BIT}, 
{0xD320, 0xA83A, I2C_16BIT}, 
{0xD322, 0x78E0, I2C_16BIT}, 
{0xD324, 0xC0F1, I2C_16BIT}, 
{0xD326, 0x0DC2, I2C_16BIT}, 
{0xD328, 0x05C0, I2C_16BIT}, 
{0xD32A, 0x7608, I2C_16BIT}, 
{0xD32C, 0x09BB, I2C_16BIT}, 
{0xD32E, 0x0010, I2C_16BIT}, 
{0xD330, 0x75CF, I2C_16BIT}, 
{0xD332, 0xFFFF, I2C_16BIT}, 
{0xD334, 0xD4E0, I2C_16BIT}, 
{0xD336, 0x8D21, I2C_16BIT}, 
{0xD338, 0x8D00, I2C_16BIT}, 
{0xD33A, 0x2153, I2C_16BIT}, 
{0xD33C, 0x0003, I2C_16BIT}, 
{0xD33E, 0xB8C0, I2C_16BIT}, 
{0xD340, 0x8D45, I2C_16BIT}, 
{0xD342, 0x0B23, I2C_16BIT}, 
{0xD344, 0x0000, I2C_16BIT}, 
{0xD346, 0xEA8F, I2C_16BIT}, 
{0xD348, 0x0915, I2C_16BIT}, 
{0xD34A, 0x001E, I2C_16BIT}, 
{0xD34C, 0xFF81, I2C_16BIT}, 
{0xD34E, 0xE808, I2C_16BIT}, 
{0xD350, 0x2540, I2C_16BIT}, 
{0xD352, 0x1900, I2C_16BIT}, 
{0xD354, 0xFFDE, I2C_16BIT}, 
{0xD356, 0x8D00, I2C_16BIT}, 
{0xD358, 0xB880, I2C_16BIT}, 
{0xD35A, 0xF004, I2C_16BIT}, 
{0xD35C, 0x8D00, I2C_16BIT}, 
{0xD35E, 0xB8A0, I2C_16BIT}, 
{0xD360, 0xAD00, I2C_16BIT}, 
{0xD362, 0x8D05, I2C_16BIT}, 
{0xD364, 0xE081, I2C_16BIT}, 
{0xD366, 0x20CC, I2C_16BIT}, 
{0xD368, 0x80A2, I2C_16BIT}, 
{0xD36A, 0xDF00, I2C_16BIT}, 
{0xD36C, 0xF40A, I2C_16BIT}, 
{0xD36E, 0x71CF, I2C_16BIT}, 
{0xD370, 0xFFFF, I2C_16BIT}, 
{0xD372, 0xC84C, I2C_16BIT}, 
{0xD374, 0x9102, I2C_16BIT}, 
{0xD376, 0x7708, I2C_16BIT}, 
{0xD378, 0xB8A6, I2C_16BIT}, 
{0xD37A, 0x2786, I2C_16BIT}, 
{0xD37C, 0x1FFE, I2C_16BIT}, 
{0xD37E, 0xB102, I2C_16BIT}, 
{0xD380, 0x0B42, I2C_16BIT}, 
{0xD382, 0x0180, I2C_16BIT}, 
{0xD384, 0x0E3E, I2C_16BIT}, 
{0xD386, 0x0180, I2C_16BIT}, 
{0xD388, 0x0F4A, I2C_16BIT}, 
{0xD38A, 0x0160, I2C_16BIT}, 
{0xD38C, 0x70C9, I2C_16BIT}, 
{0xD38E, 0x8D05, I2C_16BIT}, 
{0xD390, 0xE081, I2C_16BIT}, 
{0xD392, 0x20CC, I2C_16BIT}, 
{0xD394, 0x80A2, I2C_16BIT}, 
{0xD396, 0xF429, I2C_16BIT}, 
{0xD398, 0x76CF, I2C_16BIT}, 
{0xD39A, 0xFFFF, I2C_16BIT}, 
{0xD39C, 0xC84C, I2C_16BIT}, 
{0xD39E, 0x082D, I2C_16BIT}, 
{0xD3A0, 0x0051, I2C_16BIT}, 
{0xD3A2, 0x70CF, I2C_16BIT}, 
{0xD3A4, 0xFFFF, I2C_16BIT}, 
{0xD3A6, 0xC90C, I2C_16BIT}, 
{0xD3A8, 0x8805, I2C_16BIT}, 
{0xD3AA, 0x09B6, I2C_16BIT}, 
{0xD3AC, 0x0360, I2C_16BIT}, 
{0xD3AE, 0xD908, I2C_16BIT}, 
{0xD3B0, 0x2099, I2C_16BIT}, 
{0xD3B2, 0x0802, I2C_16BIT}, 
{0xD3B4, 0x9634, I2C_16BIT}, 
{0xD3B6, 0xB503, I2C_16BIT}, 
{0xD3B8, 0x7902, I2C_16BIT}, 
{0xD3BA, 0x1523, I2C_16BIT}, 
{0xD3BC, 0x1080, I2C_16BIT}, 
{0xD3BE, 0xB634, I2C_16BIT}, 
{0xD3C0, 0xE001, I2C_16BIT}, 
{0xD3C2, 0x1D23, I2C_16BIT}, 
{0xD3C4, 0x1002, I2C_16BIT}, 
{0xD3C6, 0xF00B, I2C_16BIT}, 
{0xD3C8, 0x9634, I2C_16BIT}, 
{0xD3CA, 0x9503, I2C_16BIT}, 
{0xD3CC, 0x6038, I2C_16BIT}, 
{0xD3CE, 0xB614, I2C_16BIT}, 
{0xD3D0, 0x153F, I2C_16BIT}, 
{0xD3D2, 0x1080, I2C_16BIT}, 
{0xD3D4, 0xE001, I2C_16BIT}, 
{0xD3D6, 0x1D3F, I2C_16BIT}, 
{0xD3D8, 0x1002, I2C_16BIT}, 
{0xD3DA, 0xFFA4, I2C_16BIT}, 
{0xD3DC, 0x9602, I2C_16BIT}, 
{0xD3DE, 0x7F05, I2C_16BIT}, 
{0xD3E0, 0xD800, I2C_16BIT}, 
{0xD3E2, 0xB6E2, I2C_16BIT}, 
{0xD3E4, 0xAD05, I2C_16BIT}, 
{0xD3E6, 0x0511, I2C_16BIT}, 
{0xD3E8, 0x05E0, I2C_16BIT}, 
{0xD3EA, 0xD800, I2C_16BIT}, 
{0xD3EC, 0xC0F1, I2C_16BIT}, 
{0xD3EE, 0x0CFE, I2C_16BIT}, 
{0xD3F0, 0x05C0, I2C_16BIT}, 
{0xD3F2, 0x0A96, I2C_16BIT}, 
{0xD3F4, 0x05A0, I2C_16BIT}, 
{0xD3F6, 0x7608, I2C_16BIT}, 
{0xD3F8, 0x0C22, I2C_16BIT}, 
{0xD3FA, 0x0240, I2C_16BIT}, 
{0xD3FC, 0xE080, I2C_16BIT}, 
{0xD3FE, 0x20CA, I2C_16BIT}, 
{0xD400, 0x0F82, I2C_16BIT}, 
{0xD402, 0x0000, I2C_16BIT}, 
{0xD404, 0x190B, I2C_16BIT}, 
{0xD406, 0x0C60, I2C_16BIT}, 
{0xD408, 0x05A2, I2C_16BIT}, 
{0xD40A, 0x21CA, I2C_16BIT}, 
{0xD40C, 0x0022, I2C_16BIT}, 
{0xD40E, 0x0C56, I2C_16BIT}, 
{0xD410, 0x0240, I2C_16BIT}, 
{0xD412, 0xE806, I2C_16BIT}, 
{0xD414, 0x0E0E, I2C_16BIT}, 
{0xD416, 0x0220, I2C_16BIT}, 
{0xD418, 0x70C9, I2C_16BIT}, 
{0xD41A, 0xF048, I2C_16BIT}, 
{0xD41C, 0x0896, I2C_16BIT}, 
{0xD41E, 0x0440, I2C_16BIT}, 
{0xD420, 0x0E96, I2C_16BIT}, 
{0xD422, 0x0400, I2C_16BIT}, 
{0xD424, 0x0966, I2C_16BIT}, 
{0xD426, 0x0380, I2C_16BIT}, 
{0xD428, 0x75CF, I2C_16BIT}, 
{0xD42A, 0xFFFF, I2C_16BIT}, 
{0xD42C, 0xD4E0, I2C_16BIT}, 
{0xD42E, 0x8D00, I2C_16BIT}, 
{0xD430, 0x084D, I2C_16BIT}, 
{0xD432, 0x001E, I2C_16BIT}, 
{0xD434, 0xFF47, I2C_16BIT}, 
{0xD436, 0x080D, I2C_16BIT}, 
{0xD438, 0x0050, I2C_16BIT}, 
{0xD43A, 0xFF57, I2C_16BIT}, 
{0xD43C, 0x0841, I2C_16BIT}, 
{0xD43E, 0x0051, I2C_16BIT}, 
{0xD440, 0x8D04, I2C_16BIT}, 
{0xD442, 0x9521, I2C_16BIT}, 
{0xD444, 0xE064, I2C_16BIT}, 
{0xD446, 0x790C, I2C_16BIT}, 
{0xD448, 0x702F, I2C_16BIT}, 
{0xD44A, 0x0CE2, I2C_16BIT}, 
{0xD44C, 0x05E0, I2C_16BIT}, 
{0xD44E, 0xD964, I2C_16BIT}, 
{0xD450, 0x72CF, I2C_16BIT}, 
{0xD452, 0xFFFF, I2C_16BIT}, 
{0xD454, 0xC700, I2C_16BIT}, 
{0xD456, 0x9235, I2C_16BIT}, 
{0xD458, 0x0811, I2C_16BIT}, 
{0xD45A, 0x0043, I2C_16BIT}, 
{0xD45C, 0xFF3D, I2C_16BIT}, 
{0xD45E, 0x080D, I2C_16BIT}, 
{0xD460, 0x0051, I2C_16BIT}, 
{0xD462, 0xD801, I2C_16BIT}, 
{0xD464, 0xFF77, I2C_16BIT}, 
{0xD466, 0xF025, I2C_16BIT}, 
{0xD468, 0x9501, I2C_16BIT}, 
{0xD46A, 0x9235, I2C_16BIT}, 
{0xD46C, 0x0911, I2C_16BIT}, 
{0xD46E, 0x0003, I2C_16BIT}, 
{0xD470, 0xFF49, I2C_16BIT}, 
{0xD472, 0x080D, I2C_16BIT}, 
{0xD474, 0x0051, I2C_16BIT}, 
{0xD476, 0xD800, I2C_16BIT}, 
{0xD478, 0xFF72, I2C_16BIT}, 
{0xD47A, 0xF01B, I2C_16BIT}, 
{0xD47C, 0x0886, I2C_16BIT}, 
{0xD47E, 0x03E0, I2C_16BIT}, 
{0xD480, 0xD801, I2C_16BIT}, 
{0xD482, 0x0EF6, I2C_16BIT}, 
{0xD484, 0x03C0, I2C_16BIT}, 
{0xD486, 0x0F52, I2C_16BIT}, 
{0xD488, 0x0340, I2C_16BIT}, 
{0xD48A, 0x0DBA, I2C_16BIT}, 
{0xD48C, 0x0200, I2C_16BIT}, 
{0xD48E, 0x0AF6, I2C_16BIT}, 
{0xD490, 0x0440, I2C_16BIT}, 
{0xD492, 0x0C22, I2C_16BIT}, 
{0xD494, 0x0400, I2C_16BIT}, 
{0xD496, 0x0D72, I2C_16BIT}, 
{0xD498, 0x0440, I2C_16BIT}, 
{0xD49A, 0x0DC2, I2C_16BIT}, 
{0xD49C, 0x0200, I2C_16BIT}, 
{0xD49E, 0x0972, I2C_16BIT}, 
{0xD4A0, 0x0440, I2C_16BIT}, 
{0xD4A2, 0x0D3A, I2C_16BIT}, 
{0xD4A4, 0x0220, I2C_16BIT}, 
{0xD4A6, 0xD820, I2C_16BIT}, 
{0xD4A8, 0x0BFA, I2C_16BIT}, 
{0xD4AA, 0x0260, I2C_16BIT}, 
{0xD4AC, 0x70C9, I2C_16BIT}, 
{0xD4AE, 0x0451, I2C_16BIT}, 
{0xD4B0, 0x05C0, I2C_16BIT}, 
{0xD4B2, 0x78E0, I2C_16BIT}, 
{0xD4B4, 0xD900, I2C_16BIT}, 
{0xD4B6, 0xF00A, I2C_16BIT}, 
{0xD4B8, 0x70CF, I2C_16BIT}, 
{0xD4BA, 0xFFFF, I2C_16BIT}, 
{0xD4BC, 0xD520, I2C_16BIT}, 
{0xD4BE, 0x7835, I2C_16BIT}, 
{0xD4C0, 0x8041, I2C_16BIT}, 
{0xD4C2, 0x8000, I2C_16BIT}, 
{0xD4C4, 0xE102, I2C_16BIT}, 
{0xD4C6, 0xA040, I2C_16BIT}, 
{0xD4C8, 0x09F1, I2C_16BIT}, 
{0xD4CA, 0x8114, I2C_16BIT}, 
{0xD4CC, 0x71CF, I2C_16BIT}, 
{0xD4CE, 0xFFFF, I2C_16BIT}, 
{0xD4D0, 0xD4E0, I2C_16BIT}, 
{0xD4D2, 0x70CF, I2C_16BIT}, 
{0xD4D4, 0xFFFF, I2C_16BIT}, 
{0xD4D6, 0xC594, I2C_16BIT}, 
{0xD4D8, 0xB03A, I2C_16BIT}, 
{0xD4DA, 0x7FE0, I2C_16BIT}, 
{0xD4DC, 0xD800, I2C_16BIT}, 
{0xD4DE, 0x0000, I2C_16BIT}, 
{0xD4E0, 0x0000, I2C_16BIT}, 
{0xD4E2, 0x0500, I2C_16BIT}, 
{0xD4E4, 0x0500, I2C_16BIT}, 
{0xD4E6, 0x0200, I2C_16BIT}, 
{0xD4E8, 0x0330, I2C_16BIT}, 
{0xD4EA, 0x0000, I2C_16BIT}, 
{0xD4EC, 0x0000, I2C_16BIT}, 
{0xD4EE, 0x03CD, I2C_16BIT}, 
{0xD4F0, 0x050D, I2C_16BIT}, 
{0xD4F2, 0x01C5, I2C_16BIT}, 
{0xD4F4, 0x03B3, I2C_16BIT}, 
{0xD4F6, 0x00E0, I2C_16BIT}, 
{0xD4F8, 0x01E3, I2C_16BIT}, 
{0xD4FA, 0x0280, I2C_16BIT}, 
{0xD4FC, 0x01E0, I2C_16BIT}, 
{0xD4FE, 0x0109, I2C_16BIT}, 
{0xD500, 0x0080, I2C_16BIT}, 
{0xD502, 0x0500, I2C_16BIT}, 
{0xD504, 0x0000, I2C_16BIT}, 
{0xD506, 0x0000, I2C_16BIT}, 
{0xD508, 0x0000, I2C_16BIT}, 
{0xD50A, 0x0000, I2C_16BIT}, 
{0xD50C, 0x0000, I2C_16BIT}, 
{0xD50E, 0x0000, I2C_16BIT}, 
{0xD510, 0x0000, I2C_16BIT}, 
{0xD512, 0x0000, I2C_16BIT}, 
{0xD514, 0x0000, I2C_16BIT}, 
{0xD516, 0x0000, I2C_16BIT}, 
{0xD518, 0x0000, I2C_16BIT}, 
{0xD51A, 0x0000, I2C_16BIT}, 
{0xD51C, 0x0000, I2C_16BIT}, 
{0xD51E, 0x0000, I2C_16BIT}, 
{0xD520, 0xFFFF, I2C_16BIT}, 
{0xD522, 0xC9B4, I2C_16BIT}, 
{0xD524, 0xFFFF, I2C_16BIT}, 
{0xD526, 0xD324, I2C_16BIT}, 
{0xD528, 0xFFFF, I2C_16BIT}, 
{0xD52A, 0xCA34, I2C_16BIT}, 
{0xD52C, 0xFFFF, I2C_16BIT}, 
{0xD52E, 0xD3EC, I2C_16BIT}, 
{0x098E, 0x0000, I2C_16BIT},  	// LOGICAL_ADDRESS_ACCESS
{0xE000, 0x04B4, I2C_16BIT},  	// PATCHLDR_LOADER_ADDRESS
{0xE002, 0x0302, I2C_16BIT},  	// PATCHLDR_PATCH_ID
{0xE004, 0x4103, I2C_16BIT},  	// PATCHLDR_FIRMWARE_ID_UPPER
{0xE006, 0x0202, I2C_16BIT},  	// PATCHLDR_FIRMWARE_ID_LOWER
{0x0080, 0xFFF0, I2C_16BIT},  	// COMMAND_REGISTER
{0x0080, 0xFFF1, I2C_16BIT},  	// COMMAND_REGISTER
{0x3640, 0x0090, I2C_16BIT},    // P_G1_P0Q0
{0x3642, 0xD46C, I2C_16BIT},    // P_G1_P0Q1
{0x3644, 0xB2A9, I2C_16BIT},    // P_G1_P0Q2
{0x3646, 0x978B, I2C_16BIT},    // P_G1_P0Q3
{0x3648, 0x8610, I2C_16BIT},    // P_G1_P0Q4
{0x364A, 0x0070, I2C_16BIT},    // P_R_P0Q0
{0x364C, 0xB26A, I2C_16BIT},    // P_R_P0Q1
{0x364E, 0x74EC, I2C_16BIT},    // P_R_P0Q2
{0x3650, 0xFD0D, I2C_16BIT},    // P_R_P0Q3
{0x3652, 0x9110, I2C_16BIT},    // P_R_P0Q4
{0x3654, 0x0030, I2C_16BIT},    // P_B_P0Q0
{0x3656, 0xB46A, I2C_16BIT},    // P_B_P0Q1
{0x3658, 0xBDED, I2C_16BIT},    // P_B_P0Q2
{0x365A, 0x8ECE, I2C_16BIT},    // P_B_P0Q3
{0x365C, 0xE10F, I2C_16BIT},    // P_B_P0Q4
{0x365E, 0x7FCF, I2C_16BIT},    // P_G2_P0Q0
{0x3660, 0xBDEC, I2C_16BIT},    // P_G2_P0Q1
{0x3662, 0x86EC, I2C_16BIT},    // P_G2_P0Q2
{0x3664, 0xC78B, I2C_16BIT},    // P_G2_P0Q3
{0x3666, 0xEE2F, I2C_16BIT},    // P_G2_P0Q4
{0x3680, 0x862B, I2C_16BIT},    // P_G1_P1Q0
{0x3682, 0x2F0D, I2C_16BIT},    // P_G1_P1Q1
{0x3684, 0x002D, I2C_16BIT},    // P_G1_P1Q2
{0x3686, 0xDB2E, I2C_16BIT},    // P_G1_P1Q3
{0x3688, 0x8B4A, I2C_16BIT},    // P_G1_P1Q4
{0x368A, 0x93AC, I2C_16BIT},    // P_R_P1Q0
{0x368C, 0x154D, I2C_16BIT},    // P_R_P1Q1
{0x368E, 0x068E, I2C_16BIT},    // P_R_P1Q2
{0x3690, 0x92EE, I2C_16BIT},    // P_R_P1Q3
{0x3692, 0xBACB, I2C_16BIT},    // P_R_P1Q4
{0x3694, 0x77A8, I2C_16BIT},    // P_B_P1Q0
{0x3696, 0x820B, I2C_16BIT},    // P_B_P1Q1
{0x3698, 0x590C, I2C_16BIT},    // P_B_P1Q2
{0x369A, 0x3B4C, I2C_16BIT},    // P_B_P1Q3
{0x369C, 0x346C, I2C_16BIT},    // P_B_P1Q4
{0x369E, 0x56AA, I2C_16BIT},    // P_G2_P1Q0
{0x36A0, 0x8FAB, I2C_16BIT},    // P_G2_P1Q1
{0x36A2, 0x27CC, I2C_16BIT},    // P_G2_P1Q2
{0x36A4, 0x1FE9, I2C_16BIT},    // P_G2_P1Q3
{0x36A6, 0xA12C, I2C_16BIT},    // P_G2_P1Q4
{0x36C0, 0x0850, I2C_16BIT},    // P_G1_P2Q0
{0x36C2, 0xBC2F, I2C_16BIT},    // P_G1_P2Q1
{0x36C4, 0xF452, I2C_16BIT},    // P_G1_P2Q2
{0x36C6, 0x0371, I2C_16BIT},    // P_G1_P2Q3
{0x36C8, 0x20F3, I2C_16BIT},    // P_G1_P2Q4
{0x36CA, 0x08D0, I2C_16BIT},    // P_R_P2Q0
{0x36CC, 0xCC6F, I2C_16BIT},    // P_R_P2Q1
{0x36CE, 0xE732, I2C_16BIT},    // P_R_P2Q2
{0x36D0, 0x0731, I2C_16BIT},    // P_R_P2Q3
{0x36D2, 0x1433, I2C_16BIT},    // P_R_P2Q4
{0x36D4, 0x01EF, I2C_16BIT},    // P_B_P2Q0
{0x36D6, 0xB16F, I2C_16BIT},    // P_B_P2Q1
{0x36D8, 0xB732, I2C_16BIT},    // P_B_P2Q2
{0x36DA, 0x0BB1, I2C_16BIT},    // P_B_P2Q3
{0x36DC, 0x0513, I2C_16BIT},    // P_B_P2Q4
{0x36DE, 0x6BAF, I2C_16BIT},    // P_G2_P2Q0
{0x36E0, 0xAAAF, I2C_16BIT},    // P_G2_P2Q1
{0x36E2, 0xD492, I2C_16BIT},    // P_G2_P2Q2
{0x36E4, 0x56D0, I2C_16BIT},    // P_G2_P2Q3
{0x36E6, 0x0413, I2C_16BIT},    // P_G2_P2Q4
{0x3700, 0xD76A, I2C_16BIT},    // P_G1_P3Q0
{0x3702, 0x9CCE, I2C_16BIT},    // P_G1_P3Q1
{0x3704, 0x5F50, I2C_16BIT},    // P_G1_P3Q2
{0x3706, 0x24AF, I2C_16BIT},    // P_G1_P3Q3
{0x3708, 0xF4D1, I2C_16BIT},    // P_G1_P3Q4
{0x370A, 0x348A, I2C_16BIT},    // P_R_P3Q0
{0x370C, 0xAE0E, I2C_16BIT},    // P_R_P3Q1
{0x370E, 0x4510, I2C_16BIT},    // P_R_P3Q2
{0x3710, 0x380F, I2C_16BIT},    // P_R_P3Q3
{0x3712, 0x8CB2, I2C_16BIT},    // P_R_P3Q4
{0x3714, 0xE6CD, I2C_16BIT},    // P_B_P3Q0
{0x3716, 0x202D, I2C_16BIT},    // P_B_P3Q1
{0x3718, 0x3090, I2C_16BIT},    // P_B_P3Q2
{0x371A, 0xDC6D, I2C_16BIT},    // P_B_P3Q3
{0x371C, 0xDF91, I2C_16BIT},    // P_B_P3Q4
{0x371E, 0x982C, I2C_16BIT},    // P_G2_P3Q0
{0x3720, 0x698D, I2C_16BIT},    // P_G2_P3Q1
{0x3722, 0x4990, I2C_16BIT},    // P_G2_P3Q2
{0x3724, 0xBDEE, I2C_16BIT},    // P_G2_P3Q3
{0x3726, 0xF451, I2C_16BIT},    // P_G2_P3Q4
{0x3740, 0xFEF1, I2C_16BIT},    // P_G1_P4Q0
{0x3742, 0x2C30, I2C_16BIT},    // P_G1_P4Q1
{0x3744, 0x7613, I2C_16BIT},    // P_G1_P4Q2
{0x3746, 0xE9F0, I2C_16BIT},    // P_G1_P4Q3
{0x3748, 0xCF33, I2C_16BIT},    // P_G1_P4Q4
{0x374A, 0xD871, I2C_16BIT},    // P_R_P4Q0
{0x374C, 0x1810, I2C_16BIT},    // P_R_P4Q1
{0x374E, 0x5273, I2C_16BIT},    // P_R_P4Q2
{0x3750, 0x97B0, I2C_16BIT},    // P_R_P4Q3
{0x3752, 0x9DD3, I2C_16BIT},    // P_R_P4Q4
{0x3754, 0x9591, I2C_16BIT},    // P_B_P4Q0
{0x3756, 0x292F, I2C_16BIT},    // P_B_P4Q1
{0x3758, 0x3033, I2C_16BIT},    // P_B_P4Q2
{0x375A, 0xE92E, I2C_16BIT},    // P_B_P4Q3
{0x375C, 0x9C53, I2C_16BIT},    // P_B_P4Q4
{0x375E, 0xDC71, I2C_16BIT},    // P_G2_P4Q0
{0x3760, 0x772F, I2C_16BIT},    // P_G2_P4Q1
{0x3762, 0x2EF3, I2C_16BIT},    // P_G2_P4Q2
{0x3764, 0xC0CD, I2C_16BIT},    // P_G2_P4Q3
{0x3766, 0x8EF2, I2C_16BIT},    // P_G2_P4Q4
{0x3782, 0x01E0, I2C_16BIT},    // CENTER_ROW
{0x3784, 0x02B4, I2C_16BIT},    // CENTER_COLUMN
{0x37C0, 0xCDAB, I2C_16BIT},  	// RESERVED_SOC2_37C0
{0x37C2, 0xAA6C, I2C_16BIT},  	// RESERVED_SOC2_37C2
{0x37C4, 0xF8AB, I2C_16BIT},  	// RESERVED_SOC2_37C4
{0x37C6, 0xE0EB, I2C_16BIT},  	// RESERVED_SOC2_37C6
{0xC95E, 0x0001, I2C_16BIT},  	// CAM_PGA_PGA_CONTROL
{0xC892, 0x0267, I2C_16BIT},  	// CAM_AWB_CCM_L_0
{0xC894, 0xFF1A, I2C_16BIT},  	// CAM_AWB_CCM_L_1
{0xC896, 0xFFB3, I2C_16BIT},  	// CAM_AWB_CCM_L_2
{0xC898, 0xFF80, I2C_16BIT},  	// CAM_AWB_CCM_L_3
{0xC89A, 0x0166, I2C_16BIT},  	// CAM_AWB_CCM_L_4
{0xC89C, 0x0003, I2C_16BIT},  	// CAM_AWB_CCM_L_5
{0xC89E, 0xFF9A, I2C_16BIT},  	// CAM_AWB_CCM_L_6
{0xC8A0, 0xFEB4, I2C_16BIT},  	// CAM_AWB_CCM_L_7
{0xC8A2, 0x024D, I2C_16BIT},  	// CAM_AWB_CCM_L_8
{0xC8A4, 0x01BF, I2C_16BIT},  	// CAM_AWB_CCM_M_0
{0xC8A6, 0xFF01, I2C_16BIT},  	// CAM_AWB_CCM_M_1
{0xC8A8, 0xFFF3, I2C_16BIT},  	// CAM_AWB_CCM_M_2
{0xC8AA, 0xFF75, I2C_16BIT},  	// CAM_AWB_CCM_M_3
{0xC8AC, 0x0198, I2C_16BIT},  	// CAM_AWB_CCM_M_4
{0xC8AE, 0xFFFD, I2C_16BIT},  	// CAM_AWB_CCM_M_5
{0xC8B0, 0xFF9A, I2C_16BIT},  	// CAM_AWB_CCM_M_6
{0xC8B2, 0xFEE7, I2C_16BIT},  	// CAM_AWB_CCM_M_7
{0xC8B4, 0x02A8, I2C_16BIT},  	// CAM_AWB_CCM_M_8
{0xC8B6, 0x01D9, I2C_16BIT},  	// CAM_AWB_CCM_R_0
{0xC8B8, 0xFF26, I2C_16BIT},  	// CAM_AWB_CCM_R_1
{0xC8BA, 0xFFF3, I2C_16BIT},  	// CAM_AWB_CCM_R_2
{0xC8BC, 0xFFB3, I2C_16BIT},  	// CAM_AWB_CCM_R_3
{0xC8BE, 0x0132, I2C_16BIT},  	// CAM_AWB_CCM_R_4
{0xC8C0, 0xFFE8, I2C_16BIT},  	// CAM_AWB_CCM_R_5
{0xC8C2, 0xFFDA, I2C_16BIT},  	// CAM_AWB_CCM_R_6
{0xC8C4, 0xFECD, I2C_16BIT},  	// CAM_AWB_CCM_R_7
{0xC8C6, 0x02C2, I2C_16BIT},  	// CAM_AWB_CCM_R_8
{0xC8C8, 0x0075, I2C_16BIT},  	// CAM_AWB_CCM_L_RG_GAIN
{0xC8CA, 0x011C, I2C_16BIT},  	// CAM_AWB_CCM_L_BG_GAIN
{0xC8CC, 0x009A, I2C_16BIT},  	// CAM_AWB_CCM_M_RG_GAIN
{0xC8CE, 0x0108, I2C_16BIT},  	// CAM_AWB_CCM_M_BG_GAIN
{0xC8D0, 0x00A4, I2C_16BIT},  	// CAM_AWB_CCM_R_RG_GAIN
{0xC8D2, 0x00AC, I2C_16BIT},  	// CAM_AWB_CCM_R_BG_GAIN
{0xC8D4, 0x0A8C, I2C_16BIT},  	// CAM_AWB_CCM_L_CTEMP
{0xC8D6, 0x1194, I2C_16BIT},  	// CAM_AWB_CCM_M_CTEMP
{0xC8D8, 0x1964, I2C_16BIT},  	// CAM_AWB_CCM_R_CTEMP
{0xC8EC, 0x1080, I2C_16BIT},  	// CAM_AWB_COLOR_TEMPERATURE_MIN
{0xC914, 0x0000, I2C_16BIT},  	// CAM_STAT_AWB_CLIP_WINDOW_XSTART
{0xC916, 0x0000, I2C_16BIT},  	// CAM_STAT_AWB_CLIP_WINDOW_YSTART
{0xC918, 0x04FF, I2C_16BIT},  	// CAM_STAT_AWB_CLIP_WINDOW_XEND
{0xC91A, 0x02CF, I2C_16BIT},  	// CAM_STAT_AWB_CLIP_WINDOW_YEND
{0xC904, 0x003A, I2C_16BIT},  	// CAM_AWB_AWB_XSHIFT_PRE_ADJ
{0xC906, 0x0040, I2C_16BIT},  	// CAM_AWB_AWB_YSHIFT_PRE_ADJ
{0xC8F2, 0x03, I2C_8BIT}, 	// CAM_AWB_AWB_XSCALE
{0xC8F3, 0x02, I2C_8BIT}, 	// CAM_AWB_AWB_YSCALE
{0xC906, 0x003C, I2C_16BIT},  	// CAM_AWB_AWB_YSHIFT_PRE_ADJ
{0xC8F4, 0x0000, I2C_16BIT},  	// CAM_AWB_AWB_WEIGHTS_0
{0xC8F6, 0x0000, I2C_16BIT},  	// CAM_AWB_AWB_WEIGHTS_1
{0xC8F8, 0xE1E0, I2C_16BIT},  	// CAM_AWB_AWB_WEIGHTS_2
{0xC8FA, 0xE0C4, I2C_16BIT},  	// CAM_AWB_AWB_WEIGHTS_3
{0xC8FC, 0x7FF3, I2C_16BIT},  	// CAM_AWB_AWB_WEIGHTS_4
{0xC8FE, 0x2045, I2C_16BIT},  	// CAM_AWB_AWB_WEIGHTS_5
{0xC900, 0xFDDC, I2C_16BIT},  	// CAM_AWB_AWB_WEIGHTS_6
{0xC902, 0x7F7C, I2C_16BIT},  	// CAM_AWB_AWB_WEIGHTS_7
{0xC90C, 0x80, I2C_8BIT}, 	// CAM_AWB_K_R_L
{0xC90D, 0x80, I2C_8BIT}, 	// CAM_AWB_K_G_L
{0xC90E, 0x80, I2C_8BIT}, 	// CAM_AWB_K_B_L
{0xC90F, 0x88, I2C_8BIT}, 	// CAM_AWB_K_R_R
{0xC910, 0x80, I2C_8BIT}, 	// CAM_AWB_K_G_R
{0xC911, 0x80, I2C_8BIT}, 	// CAM_AWB_K_B_R
{0xC909, 0x02, I2C_8BIT}, 	// CAM_AWB_AWBMODE
{0xC926, 0x00B0, I2C_16BIT},  	// CAM_LL_START_BRIGHTNESS
{0xC928, 0x01F0, I2C_16BIT},  	// CAM_LL_STOP_BRIGHTNESS
{0xC946, 0x0022, I2C_16BIT},  	// CAM_LL_START_GAIN_METRIC
{0xC948, 0x0075, I2C_16BIT},  	// CAM_LL_STOP_GAIN_METRIC
{0xC952, 0x00B0, I2C_16BIT},  	// CAM_LL_START_TARGET_LUMA_BM
{0xC954, 0x01F0, I2C_16BIT},  	// CAM_LL_STOP_TARGET_LUMA_BM
{0xC92A, 0x55, I2C_8BIT}, 	// CAM_LL_START_SATURATION
{0xC92B, 0x35, I2C_8BIT}, 	// CAM_LL_END_SATURATION
{0xC92C, 0x00, I2C_8BIT}, 	// CAM_LL_START_DESATURATION
{0xC92D, 0xE0, I2C_8BIT}, 	// CAM_LL_END_DESATURATION
{0xC92E, 0x19, I2C_8BIT}, 	// CAM_LL_START_DEMOSAIC
{0xC92F, 0x03, I2C_8BIT}, 	// CAM_LL_START_AP_GAIN
{0xC930, 0x03, I2C_8BIT}, 	// CAM_LL_START_AP_THRESH
{0xC931, 0x46, I2C_8BIT}, 	// CAM_LL_STOP_DEMOSAIC
{0xC932, 0x02, I2C_8BIT}, 	// CAM_LL_STOP_AP_GAIN
{0xC933, 0x0C, I2C_8BIT}, 	// CAM_LL_STOP_AP_THRESH
{0xC934, 0x15, I2C_8BIT}, 	// CAM_LL_START_NR_RED
{0xC935, 0x10, I2C_8BIT}, 	// CAM_LL_START_NR_GREEN
{0xC936, 0x15, I2C_8BIT}, 	// CAM_LL_START_NR_BLUE
{0xC937, 0x03, I2C_8BIT}, 	// CAM_LL_START_NR_THRESH
{0xC938, 0x38, I2C_8BIT}, 	// CAM_LL_STOP_NR_RED
{0xC939, 0x32, I2C_8BIT}, 	// CAM_LL_STOP_NR_GREEN
{0xC93A, 0x38, I2C_8BIT}, 	// CAM_LL_STOP_NR_BLUE
{0xC93B, 0x32, I2C_8BIT}, 	// CAM_LL_STOP_NR_THRESH
{0xC924, 0x0003, I2C_16BIT},  	// CAM_LL_LLMODE
{0xC93C, 0x0020, I2C_16BIT},  	// CAM_LL_START_CONTRAST_BM
{0xC93E, 0x009A, I2C_16BIT},  	// CAM_LL_STOP_CONTRAST_BM
{0xC940, 0x00F7, I2C_16BIT},  	// CAM_LL_GAMMA
{0xBC0A, 0x08, I2C_8BIT}, 	// LL_GAMMA_CONTRAST_CURVE_0
{0xC942, 0x3C, I2C_8BIT}, 	// CAM_LL_START_CONTRAST_GRADIENT
{0xC943, 0x30, I2C_8BIT}, 	// CAM_LL_STOP_CONTRAST_GRADIENT
{0xC944, 0x50, I2C_8BIT}, 	// CAM_LL_START_CONTRAST_LUMA_PERCENTAGE
{0xC945, 0x14, I2C_8BIT}, 	// CAM_LL_STOP_CONTRAST_LUMA_PERCENTAGE
{0xC94A, 0x0080, I2C_16BIT},  	// CAM_LL_START_FADE_TO_BLACK_LUMA
{0xC94C, 0x0010, I2C_16BIT},  	// CAM_LL_STOP_FADE_TO_BLACK_LUMA
{0xC94E, 0x0080, I2C_16BIT},  	// CAM_LL_CLUSTER_DC_TH_BM
{0xC950, 0x05, I2C_8BIT}, 	// CAM_LL_CLUSTER_DC_GATE_PERCENTAGE
{0xC951, 0x40, I2C_8BIT}, 	// CAM_LL_SUMMING_SENSITIVITY_FACTOR
{0xC87A, 0x2E, I2C_8BIT}, 	// CAM_AET_TARGET_AVERAGE_LUMA
{0xC87B, 0x2A, I2C_8BIT}, 	// CAM_AET_TARGET_AVERAGE_LUMA_DARK
{0xC878, 0x0C, I2C_8BIT}, 	// CAM_AET_AEMODE
{0xC890, 0x0036, I2C_16BIT},  	// CAM_AET_TARGET_GAIN
{0xC886, 0x0100, I2C_16BIT},  	// CAM_AET_AE_MAX_VIRT_AGAIN
{0xB42A, 0x05, I2C_8BIT}, 	// CCM_DELTA_GAIN
{0xA80A, 0x18, I2C_8BIT}, 	// AE_TRACK_AE_TRACKING_DAMPENING_SPEED
{0xB00C, 0x0C, I2C_8BIT}, 	// BLACKLEVEL_MAX_BLACK_LEVEL
{0xC87C, 0x005A, I2C_16BIT},  	// CAM_AET_BLACK_CLIPPING_TARGET
{0x098E, 0x4984, I2C_16BIT},  	// LOGICAL_ADDRESS_ACCESS
{0xC984, 0x8040, I2C_16BIT},  	// CAM_PORT_OUTPUT_CONTROL
{0xC988, 0x0F00, I2C_16BIT},  	// CAM_PORT_MIPI_TIMING_T_HS_ZERO
{0xC98A, 0x0B07, I2C_16BIT},  	// CAM_PORT_MIPI_TIMING_T_HS_EXIT_HS_TRAIL
{0xC98C, 0x0D01, I2C_16BIT},  	// CAM_PORT_MIPI_TIMING_T_CLK_POST_CLK_PRE
{0xC98E, 0x071D, I2C_16BIT},  	// CAM_PORT_MIPI_TIMING_T_CLK_TRAIL_CLK_ZERO
{0xC990, 0x0006, I2C_16BIT},  	// CAM_PORT_MIPI_TIMING_T_LPX
{0xC992, 0x0A0C, I2C_16BIT},  	// CAM_PORT_MIPI_TIMING_INIT_TIMING
{0x3C5A, 0x0009, I2C_16BIT},  	// RESERVED_TX_SS_3C5A
{0x001E, 0x0777, I2C_16BIT},  	// PAD_SLEW
{0xDC00, 0x34, I2C_8BIT}, 	// SYSMGR_NEXT_STATE
{0x0080, 0x8002, I2C_16BIT},  	// COMMAND_REGISTER
{I2C_REG_TERM, I2C_VAL_TERM, I2C_LEN_TERM}
};

static enum v4l2_mbus_pixelcode soc1040_codes[] = {
	V4L2_MBUS_FMT_UYVY8_2X8,
};

static struct v4l2_subdev_frame_size_enum soc1040_sizes[] = {
	{
		.index 		= 1,
		.pad   		= 0,
		.code		= V4L2_MBUS_FMT_UYVY8_2X8,
		.min_width 	= 1280,
		.min_height 	= 720,
		.max_width 	= 1280,
		.max_height 	= 720,
	},
};

static const struct v4l2_queryctrl soc1040_controls[] = {
	{
		.id		= V4L2_CID_VFLIP,
		.type		= V4L2_CTRL_TYPE_BOOLEAN,
		.name		= "Flip Vertically",
		.minimum	= 0,
		.maximum	= 1,
		.step		= 1,
		.default_value	= 0,
	},
	{
		.id		= V4L2_CID_HFLIP,
		.type		= V4L2_CTRL_TYPE_BOOLEAN,
		.name		= "Flip Horizontally",
		.minimum	= 0,
		.maximum	= 1,
		.step		= 1,
		.default_value	= 0,
	},
};

/**
 * soc1040_read_reg - Read a value from a register in an soc1040 sensor device
 * @client: i2c driver client structure
 * @data_length: length of data to be read
 * @reg: register address / offset
 * @val: stores the value that gets read
 *
 * Read a value from a register in an soc1040 sensor device.
 * The value is returned in 'val'.
 * Returns zero if successful, or non-zero otherwise.
 */
static int
soc1040_read_reg(struct i2c_client *client, u16 data_length, u16 reg, u32 *val)
{
	int err;
	struct i2c_msg msg[1];
	unsigned char data[4];

	if (!client->adapter)
		return -ENODEV;
	if (data_length != I2C_8BIT && data_length != I2C_16BIT
			&& data_length != I2C_32BIT)
		return -EINVAL;

	msg->addr = client->addr;
	msg->flags = 0;
	msg->len = 2;
	msg->buf = data;

	/* Write addr - high byte goes out first */
	data[0] = (u8) (reg >> 8);;
	data[1] = (u8) (reg & 0xff);
	err = i2c_transfer(client->adapter, msg, 1);

	/* Read back data */
	if (err >= 0) {
		msg->len = data_length;
		msg->flags = I2C_M_RD;
		err = i2c_transfer(client->adapter, msg, 1);
	}
	if (err >= 0) {
		*val = 0;
		/* high byte comes first */
		if (data_length == I2C_8BIT)
			*val = data[0];
		else if (data_length == I2C_16BIT)
			*val = data[1] + (data[0] << 8);
		else
			*val = data[3] + (data[2] << 8) +
				(data[1] << 16) + (data[0] << 24);
		return 0;
	}
	v4l_err(client, "read from offset 0x%x error %d\n", reg, err);
	return err;
}

/**
 * Write a value to a register in soc1040 sensor device.
 * @client: i2c driver client structure.
 * @reg: Address of the register to read value from.
 * @val: Value to be written to a specific register.
 * Returns zero if successful, or non-zero otherwise.
 */
static int soc1040_write_reg(struct i2c_client *client, u16 reg,
						u32 val, u16 data_length)
{
	int err = 0;
	struct i2c_msg msg[1];
	unsigned char data[6];
	int retries = 0;

	if (!client->adapter)
		return -ENODEV;

	if (data_length != I2C_8BIT && data_length != I2C_16BIT
			&& data_length != I2C_32BIT)
		return -EINVAL;

retry:
	msg->addr = client->addr;
	msg->flags = I2C_M_WR;
	msg->len = data_length+2;  /* add address bytes */
	msg->buf = data;

	/* high byte goes out first */
	data[0] = (u8) (reg >> 8);
	data[1] = (u8) (reg & 0xff);
	if (data_length == I2C_8BIT) {
		data[2] = val & 0xff;
	} else if (data_length == I2C_16BIT) {
		data[2] = (val >> 8) & 0xff;
		data[3] = val & 0xff;
	} else {
		data[2] = (val >> 24) & 0xff;
		data[3] = (val >> 16) & 0xff;
		data[4] = (val >> 8) & 0xff;
		data[5] = val & 0xff;
	}

	if (data_length == 1)
		dev_dbg(&client->dev, "SOC1040 Wrt:[0x%04X]=0x%02X\n",
				reg, val);
	else if (data_length == 2)
		dev_dbg(&client->dev, "SOC1040 Wrt:[0x%04X]=0x%04X\n",
				reg, val);

	err = i2c_transfer(client->adapter, msg, 1);

	if (err >= 0)
		return 0;

	if (retries <= 5) {
		v4l_info(client, "Retrying I2C... %d", retries);
		retries++;
		mdelay(20);
		goto retry;
	}

	return err;
}

/**
 * Initialize a list of soc1040 registers.
 * The list of registers is terminated by the pair of values
 * {OV3640_REG_TERM, OV3640_VAL_TERM}.
 * @client: i2c driver client structure.
 * @reglist[]: List of address of the registers to write data.
 * Returns zero if successful, or non-zero otherwise.
 */
static int soc1040_write_regs(struct i2c_client *client,
					const struct soc1040_reg reglist[])
{
	int err = 0;
	const struct soc1040_reg *list = reglist;

	while (!((list->reg == I2C_REG_TERM)
		&& (list->val == I2C_VAL_TERM))) {
		err = soc1040_write_reg(client, list->reg,
				list->val, list->length);
		if (err)
			return err;
		list++;
	}
	return 0;
}

/* Start/Stop streaming from the device */
static int soc1040_s_stream(struct v4l2_subdev *sd, int enable)
{
	struct i2c_client *client = v4l2_get_subdevdata(sd);
	struct soc1040_priv *priv = to_soc1040_sensor(sd);
	int ret=0;
#if 0
	/* Program orientation register. */
	if (priv->flag_vflip)
		ret = soc1040_reg_rmw(client, SOC1040_IMAGE_ORT, 0x2, 0);
	else
		ret = soc1040_reg_rmw(client, SOC1040_IMAGE_ORT, 0, 0x2);
	if (IS_ERR_VALUE(ret))
		return ret;

	if (priv->flag_hflip)
		ret = soc1040_reg_rmw(client, SOC1040_IMAGE_ORT, 0x1, 0);
	else
		ret = soc1040_reg_rmw(client, SOC1040_IMAGE_ORT, 0, 0x1);
	if (IS_ERR_VALUE(ret))
		return ret;

	if (enable) {
		dev_info(&client->dev, "Enabling Streaming\n");
		ret = soc1040_reg_write_ary(client, soc1040_start_streaming,
					   ARRAY_SIZE(soc1040_start_streaming));
	} else {
		dev_info(&client->dev, "Disabling Streaming\n");
		ret = soc1040_reg_write_ary(client, soc1040_stop_streaming,
					   ARRAY_SIZE(soc1040_stop_streaming));
	}
#endif
	return ret;
}



/* Get status of additional camera capabilities */
static int soc1040_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
{
	struct soc1040_priv *priv = to_soc1040_sensor(sd);

	switch (ctrl->id) {
	case V4L2_CID_VFLIP:
		ctrl->value = priv->flag_vflip;
		break;
	case V4L2_CID_HFLIP:
		ctrl->value = priv->flag_hflip;
		break;
	default:
		return -EINVAL;
	}

	return 0;
}

/* Set status of additional camera capabilities */
static int soc1040_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
{
	struct soc1040_priv *priv = to_soc1040_sensor(sd);

	switch (ctrl->id) {
	case V4L2_CID_VFLIP:
		priv->flag_vflip = ctrl->value;
		break;
	case V4L2_CID_HFLIP:
		priv->flag_hflip = ctrl->value;
		break;
	default:
		return -EINVAL;
	}

	return 0;
}

/* Get chip identification */
static int soc1040_g_chip_ident(struct v4l2_subdev *sd,
			       struct v4l2_dbg_chip_ident *id)
{
	struct soc1040_priv *priv = to_soc1040_sensor(sd);

	id->ident = priv->ident;
	id->revision = priv->revision;

	return 0;
}

#ifdef CONFIG_VIDEO_ADV_DEBUG
static int soc1040_get_register(struct v4l2_subdev *sd,
			       struct v4l2_dbg_register *reg)
{
	struct i2c_client *client = v4l2_get_subdevdata(sd);
	int ret;
	u8 val;

	if (reg->reg & ~0xffff)
		return -EINVAL;

	reg->size = 2;

	ret = soc1040_read_reg(client, 2, reg->reg, &val);
	if (ret)
		return ret;

	reg->val = (__u64)val;

	return ret;
}

static int soc1040_set_register(struct v4l2_subdev *sd,
			       struct v4l2_dbg_register *reg)
{
	struct i2c_client *client = v4l2_get_subdevdata(sd);

	if (reg->reg & ~0xffff || reg->val & ~0xff)
		return -EINVAL;

	return soc1040_write_reg(client, reg->reg, reg->val,2);
}
#endif

/* select nearest higher resolution for capture */
static int soc1040_res_roundup(u32 *width, u32 *height)
{
	int i;

	for (i = 0; i < ARRAY_SIZE(soc1040_sizes); i++)
		if (soc1040_sizes[i].max_width >= *width &&
			soc1040_sizes[i].max_height >= *height) {
			*width = soc1040_sizes[i].max_width;
			*height = soc1040_sizes[i].max_height;
			return i;
		}

	*width = soc1040_sizes[ARRAY_SIZE(soc1040_sizes) - 1].max_width;
	*height = soc1040_sizes[ARRAY_SIZE(soc1040_sizes) - 1].max_height;

	return ARRAY_SIZE(soc1040_sizes) - 1;
}

/* Setup registers according to resolution and color encoding */
static int soc1040_set_res_code(struct i2c_client *client, u32 width,
			       enum v4l2_mbus_pixelcode code)
{
	int ret=0;

	/* select register configuration for given resolution */
	switch (width) {
	case RES_1280x720_W:
		dev_info(&client->dev, "Setting image size to 1280x720\n");
        mdelay(100);
        soc1040_write_reg(client, 0x098e, 0x4984, I2C_16BIT);
	    soc1040_write_reg(client, 0xc984, 0x8041, I2C_16BIT);
	    soc1040_write_reg(client, 0x3c5a, 0x0009, I2C_16BIT);
	    soc1040_write_reg(client, 0xDC00, 0x34, I2C_8BIT);
	    soc1040_write_reg(client, 0x0080, 0x8002, I2C_16BIT);
	    mdelay(300);
	    soc1040_write_reg(client, 0xDC00, 0x28, I2C_8BIT);
	    soc1040_write_reg(client, 0x0080, 0x8002, I2C_16BIT);
	    mdelay(300);

	    printk("gated mipi clock\n");

		/*ret = soc1040_reg_write_ary(client, soc1040_regs_1280x720,
					   ARRAY_SIZE(soc1040_regs_1280x720));
		*/
        break;
	default:
		dev_err(&client->dev, "Failed to select resolution!\n");
		return -EINVAL;
	}

	return ret;
}

/* set the format we will capture in */
static int soc1040_s_fmt(struct v4l2_subdev *sd,
			struct v4l2_mbus_framefmt *mf)
{
	struct i2c_client *client = v4l2_get_subdevdata(sd);
	enum v4l2_colorspace cspace;
	enum v4l2_mbus_pixelcode code = mf->code;
	int ret;

	soc1040_res_roundup(&mf->width, &mf->height);

	switch (code) {
	case V4L2_MBUS_FMT_UYVY8_2X8:
		cspace = V4L2_COLORSPACE_SRGB;
		break;
	default:
		return -EINVAL;
	}

	ret = soc1040_write_regs(client, soc1040_defaults);
	if (IS_ERR_VALUE(ret))
		return ret;

	ret = soc1040_set_res_code(client, mf->width, code);
	if (IS_ERR_VALUE(ret))
		return ret;

	mf->code	= code;
	mf->colorspace	= cspace;

	return ret;
}

static int soc1040_try_fmt(struct v4l2_subdev *sd,
			  struct v4l2_mbus_framefmt *mf)
{
	soc1040_res_roundup(&mf->width, &mf->height);

	mf->field = V4L2_FIELD_NONE;

	switch (mf->code) {
	case V4L2_MBUS_FMT_UYVY8_2X8:
		mf->colorspace = V4L2_COLORSPACE_SRGB;
		break;
	default:
		return -EINVAL;
	}

	return 0;
}

/* -----------------------------------------------------------------------------
 * V4L2 subdev video operations
 */

static int soc1040_pad_enum_mbus_code(struct v4l2_subdev *subdev,
				 struct v4l2_subdev_fh *fh,
				 struct v4l2_subdev_mbus_code_enum *code_enum)
{
	if (code_enum->index >= ARRAY_SIZE(soc1040_codes))
		return -EINVAL;

	code_enum->pad  = 0;
	code_enum->code = soc1040_codes[code_enum->index];

	return 0;
}

static int soc1040_pad_enum_frame_size(struct v4l2_subdev *subdev,
				  struct v4l2_subdev_fh *fh,
				  struct v4l2_subdev_frame_size_enum *fse)
{
	if (fse->pad != 0)
		return -EINVAL;

	if (fse->index >= ARRAY_SIZE(soc1040_sizes))
		return -EINVAL;

	if (fse->code != soc1040_codes[fse->index])
		return -EINVAL;

	*fse = soc1040_sizes[fse->index];

	return 0;
}

static struct v4l2_mbus_framefmt *
__soc1040_pad_get_format(struct soc1040_priv *sensor, struct v4l2_subdev_fh *fh,
			unsigned int pad, enum v4l2_subdev_format_whence which)
{
	if (pad != 0)
		return NULL;

	switch (which) {
	case V4L2_SUBDEV_FORMAT_TRY:
		return v4l2_subdev_get_try_format(fh, pad);
	case V4L2_SUBDEV_FORMAT_ACTIVE:
		return &sensor->format;
	default:
		return NULL;
	}
}

static int soc1040_pad_get_format(struct v4l2_subdev *subdev,
				 struct v4l2_subdev_fh *fh,
				 struct v4l2_subdev_format *fmt)
{
	struct soc1040_priv *sensor = to_soc1040_sensor(subdev);
	struct v4l2_mbus_framefmt *format;

	format = __soc1040_pad_get_format(sensor, fh, fmt->pad, fmt->which);
	if (format == NULL)
		return -EINVAL;

	fmt->format = *format;
	return 0;
}

static int soc1040_pad_set_format(struct v4l2_subdev *subdev,
				 struct v4l2_subdev_fh *fh,
				 struct v4l2_subdev_format *fmt)
{
	struct soc1040_priv *sensor = to_soc1040_sensor(subdev);
	struct v4l2_mbus_framefmt *format;
	int ret;

	format = __soc1040_pad_get_format(sensor, fh, fmt->pad, fmt->which);
	if (format == NULL)
		return -EINVAL;

	ret = soc1040_try_fmt(subdev, &fmt->format);
	if (ret)
		return ret;

	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE) {

		/* TODO: please check */
		sensor->pdata->csi_configure(subdev, 0);

		ret = soc1040_s_fmt(subdev, &fmt->format);
		if (ret)
			return ret;

		sensor->format = fmt->format;
	}

	return 0;
}

static int soc1040_set_power(struct v4l2_subdev *subdev, int on)
{
	struct soc1040_priv *sensor = to_soc1040_sensor(subdev);
	struct soc1040_platform_data *pdata = sensor->pdata;
	int ret = 0;

	if (!pdata || !pdata->set_power || !pdata->set_xclk)
		return -EINVAL;

	/* If the power count is modified from 0 to != 0 or from != 0 to 0,
	 * update the power state.
	 */
	if (sensor->power_count == !on) {
		if (on) {
			pdata->set_xclk(subdev, pdata->ext_clk);
			udelay(1000);
			ret = pdata->set_power(subdev, 1);

		} else {
			ret = pdata->set_power(subdev, 0);
			udelay(100);
			pdata->set_xclk(subdev, 0);
		}

		if (ret < 0)
			goto done;
	}

	/* Update the power count. */
	sensor->power_count += on ? 1 : -1;
	WARN_ON(sensor->power_count < 0);

done:
	return ret;
}

static int soc1040_detect(struct v4l2_subdev *sd)
{
	struct i2c_client *client = v4l2_get_subdevdata(sd);
	u32 model_id, mfr_id, rev;

	if (!client)
		return -ENODEV;
#if 0
	if (soc1040_read_reg(client, 2, SOC1040_MODEL_ID_HI, &model_id))
		return -ENODEV;
	if (soc1040_read_reg(client, 1, SOC1040_MANUFACTURER_ID, &mfr_id))
		return -ENODEV;
	if (soc1040_read_reg(client, 1, SOC1040_REVISION_NUMBER, &rev))
		return -ENODEV;


	v4l_info(client, "model id detected 0x%x mfr 0x%x, rev# 0x%x\n",
							model_id, mfr_id, rev);
	if (model_id != 0x9740) {
		/* We didn't read the values we expected, so
		 * this must not be an SOC1040.
		 */
		v4l_warn(client, "model id mismatch 0x%x mfr 0x%x\n",
							model_id, mfr_id);

		return -ENODEV;
	}
#endif
	return 0;
}

static int soc1040_registered(struct v4l2_subdev *subdev)
{
	struct i2c_client *client = v4l2_get_subdevdata(subdev);
	int ret;

	ret = soc1040_set_power(subdev, 1);
	if (ret) {
		v4l_warn(client, "Power on failed\n");
		return ret;
	}

	ret = soc1040_detect(subdev);

	soc1040_set_power(subdev, 0);

	return ret;
}

static int soc1040_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
{
	struct soc1040_priv *sensor = to_soc1040_sensor(sd);
	struct v4l2_mbus_framefmt *format;

	format = __soc1040_pad_get_format(sensor, fh, 0, V4L2_SUBDEV_FORMAT_TRY);
	if (!format)
		return -EINVAL;

	memset(format, 0, sizeof(*format));

	format->code = V4L2_MBUS_FMT_UYVY8_2X8;

	soc1040_try_fmt(sd, format);

	return soc1040_set_power(sd, 1);
}

static int soc1040_close(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
{
	return soc1040_set_power(sd, 0);
}


static struct v4l2_subdev_core_ops soc1040_core_ops = {
	.s_power		= soc1040_set_power,
	.g_ctrl			= soc1040_g_ctrl,
	.s_ctrl			= soc1040_s_ctrl,
#ifdef CONFIG_VIDEO_ADV_DEBUG
	.g_register		= soc1040_get_register,
	.s_register		= soc1040_set_register,
#endif
};

static const struct v4l2_subdev_pad_ops soc1040_pad_ops = {
	.enum_mbus_code 	= soc1040_pad_enum_mbus_code,
	.enum_frame_size 	= soc1040_pad_enum_frame_size,
	.get_fmt 		= soc1040_pad_get_format,
	.set_fmt 		= soc1040_pad_set_format,
};

static struct v4l2_subdev_video_ops soc1040_video_ops = {
	.s_stream		= soc1040_s_stream,

};

static struct v4l2_subdev_ops soc1040_subdev_ops = {
	.core			= &soc1040_core_ops,
	.video			= &soc1040_video_ops,
	.pad 			= &soc1040_pad_ops,
};

static const struct v4l2_subdev_internal_ops soc1040_internal_ops = {
	.registered 		= soc1040_registered,
	.open 			= soc1040_open,
	.close 			= soc1040_close,
};

/*
 * i2c_driver function
 */
static int __devinit soc1040_probe(struct i2c_client *client,
				  const struct i2c_device_id *did)
{
	struct soc1040_platform_data *pdata;
	struct v4l2_mbus_framefmt *format;
	struct soc1040_priv *sensor;
	int rval;

	pdata = (struct soc1040_platform_data *) client->dev.platform_data;

	if (pdata == NULL)
		return -ENODEV;

	sensor = kzalloc(sizeof(*sensor), GFP_KERNEL);
	if (sensor == NULL)
		return -ENOMEM;

	sensor->pdata = pdata;

	v4l2_i2c_subdev_init(&sensor->subdev, client, &soc1040_subdev_ops);

	format = __soc1040_pad_get_format(sensor, NULL, 0,
					 V4L2_SUBDEV_FORMAT_ACTIVE);

	memset(format, 0, sizeof(*format));

	format->code = V4L2_MBUS_FMT_UYVY8_2X8;

	soc1040_try_fmt(&sensor->subdev, format);

	sensor->subdev.internal_ops = &soc1040_internal_ops;
	sensor->subdev.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;

	sensor->pad.flags = MEDIA_PAD_FL_SOURCE;
	rval = media_entity_init(&sensor->subdev.entity, 1, &sensor->pad, 0);
	if (rval < 0)
		kfree(sensor);

	return rval;
}

static int __devexit soc1040_remove(struct i2c_client *client)
{
	struct v4l2_subdev *subdev = i2c_get_clientdata(client);
	struct soc1040_priv *sensor = to_soc1040_sensor(subdev);

	if (sensor->power_count && sensor->pdata) {
		if (sensor->pdata->set_power)
			sensor->pdata->set_power(&sensor->subdev, 0);

		sensor->pdata->set_xclk(&sensor->subdev, 0);
		sensor->power_count = 0;
	}

	media_entity_cleanup(&sensor->subdev.entity);
	v4l2_device_unregister_subdev(subdev);
	kfree(sensor);

	return 0;
}

static const struct i2c_device_id soc1040_id[] = {
	{ "soc1040", 0 },
	{ }
};
MODULE_DEVICE_TABLE(i2c, soc1040_id);

static struct i2c_driver soc1040_i2c_driver = {
	.driver = {
		.name = "soc1040",
	},
	.probe    = soc1040_probe,
	.remove   = __devexit_p(soc1040_remove),
	.id_table = soc1040_id,
};

static int __init soc1040_module_init(void)
{
	return i2c_add_driver(&soc1040_i2c_driver);
}

static void __exit soc1040_module_exit(void)
{
	i2c_del_driver(&soc1040_i2c_driver);
}

module_init(soc1040_module_init);
module_exit(soc1040_module_exit);

MODULE_DESCRIPTION("SoC Camera driver for OmniVision SOC1040");
MODULE_AUTHOR("Julien BERAUD <julien.beraud@parrot.com>");
MODULE_LICENSE("GPL v2");
