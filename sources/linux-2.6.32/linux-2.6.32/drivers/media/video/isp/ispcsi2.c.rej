--- drivers/media/video/isp/ispcsi2.c
+++ drivers/media/video/isp/ispcsi2.c
@@ -1,1850 +1,780 @@
 /*
  * ispcsi2.c
  *
- * Driver Library for ISP CSI Control module in TI's OMAP3 Camera ISP
- * ISP CSI interface and IRQ related APIs are defined here.
+ * TI OMAP3 ISP - CSI2 module
  *
- * Copyright (C) 2009 Texas Instruments.
+ * Copyright (C) 2010 Nokia Corporation
+ * Copyright (C) 2009 Texas Instruments, Inc.
  *
- * Contributors:
- * 	Sergio Aguirre <saaguirre@ti.com>
- * 	Dominic Curran <dcurran@ti.com>
+ * Contacts: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
+ *	     Sakari Ailus <sakari.ailus@maxwell.research.nokia.com>
  *
- * This package is free software; you can redistribute it and/or modify
+ * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
  */
-
-#define DEBUG 1
 #include <linux/delay.h>
 #include <media/v4l2-common.h>
+#include <linux/v4l2-mediabus.h>
+#include <linux/mm.h>
+
 #include "isp.h"
 #include "ispreg.h"
 #include "ispcsi2.h"
-#ifdef CONFIG_VIDEO_OMAP34XX_ISP_DEBUG_FS
-#include "ispcsi2_dfs.h"
-#endif
 
-/**
- * isp_csi2_complexio_lanes_config - Configuration of CSI2 ComplexIO lanes.
- * @reqcfg: Pointer to structure containing desired lane configuration
+/*
+ * csi2_if_enable - Enable CSI2 Receiver interface.
+ * @enable: enable flag
  *
- * Validates and saves to internal driver memory the passed configuration.
- * Returns 0 if successful, or -EINVAL if null pointer is passed, invalid
- * lane position or polarity is set, and if 2 lanes try to occupy the same
- * position. To apply this settings, use the isp_csi2_complexio_lanes_update()
- * function just after calling this function.
- **/
-int isp_csi2_complexio_lanes_config(struct isp_csi2_device *isp_csi2,
-				    struct isp_csi2_lanes_cfg *reqcfg)
+ */
+static void csi2_if_enable(struct isp_device *isp,
+			   struct isp_csi2_device *csi2, u8 enable)
 {
-	int i;
-	bool pos_occupied[5] = {false, false, false, false, false};
-	struct isp_csi2_lanes_cfg *currlanes = &isp_csi2->current_cfg.lanes;
-	struct isp_csi2_lanes_cfg_update *currlanes_u =
-		&isp_csi2->current_cfg_update.lanes;
-
-	/* Validating parameters sent by driver */
-	if (reqcfg == NULL) {
-		printk(KERN_ERR "Invalid Complex IO Configuration sent by"
-		       " sensor\n");
-		goto err_einval;
-	}
+	struct isp_csi2_ctrl_cfg *currctrl = &csi2->ctrl;
 
-	/* Data lanes verification */
-	for (i = 0; i < 4; i++) {
-		if ((reqcfg->data[i].pol > 1) || (reqcfg->data[i].pos > 5)) {
-			printk(KERN_ERR "Invalid CSI-2 Complex IO configuration"
-			       " parameters for data lane #%d\n", i);
-			goto err_einval;
-		}
-		if (!reqcfg->data[i].pos)
-			continue;
-
-		if (pos_occupied[reqcfg->data[i].pos - 1]) {
-			printk(KERN_ERR "Lane #%d already occupied\n",
-			       reqcfg->data[i].pos);
-			goto err_einval;
-		} else
-			pos_occupied[reqcfg->data[i].pos - 1] = true;
-	}
-
-	/* Clock lane verification */
-	if ((reqcfg->clk.pol > 1) || (reqcfg->clk.pos > 5) ||
-	    (reqcfg->clk.pos == 0)) {
-		printk(KERN_ERR "Invalid CSI-2 Complex IO configuration"
-		       " parameters for clock lane\n");
-		goto err_einval;
-	}
-	if (pos_occupied[reqcfg->clk.pos - 1]) {
-		printk(KERN_ERR "Lane #%d already occupied",
-		       reqcfg->clk.pos);
-		goto err_einval;
-	} else
-		pos_occupied[reqcfg->clk.pos - 1] = true;
-
-	for (i = 0; i < 4; i++) {
-		if (currlanes->data[i].pos != reqcfg->data[i].pos) {
-			currlanes->data[i].pos = reqcfg->data[i].pos;
-			currlanes_u->data[i] = true;
-			isp_csi2->update_complexio_cfg1 = true;
-		}
-		if (currlanes->data[i].pol != reqcfg->data[i].pol) {
-			currlanes->data[i].pol = reqcfg->data[i].pol;
-			currlanes_u->data[i] = true;
-			isp_csi2->update_complexio_cfg1 = true;
-		}
-		/* If the lane position is non zero then we can assume that
-		 * the initial lane state is on.
-		 */
-		if (currlanes->data[i].pos)
-			currlanes->data[i].state = ISP_CSI2_LANE_ON;
-	}
+	isp_reg_clr_set(isp, csi2->regs1, ISPCSI2_CTRL, ISPCSI2_CTRL_IF_EN,
+			enable ? ISPCSI2_CTRL_IF_EN : 0);
 
-	if (currlanes->clk.pos != reqcfg->clk.pos) {
-		currlanes->clk.pos = reqcfg->clk.pos;
-		currlanes_u->clk = true;
-		isp_csi2->update_complexio_cfg1 = true;
-	}
-	if (currlanes->clk.pol != reqcfg->clk.pol) {
-		currlanes->clk.pol = reqcfg->clk.pol;
-		currlanes_u->clk = true;
-		isp_csi2->update_complexio_cfg1 = true;
-	}
-	return 0;
-err_einval:
-	return -EINVAL;
+	currctrl->if_enable = enable;
 }
 
-/**
- * isp_csi2_complexio_lanes_update - Applies CSI2 ComplexIO lanes configuration.
- * @force_update: Flag to force rewrite of registers, even if they haven't been
- *                updated with the isp_csi2_complexio_lanes_config() function.
+/*
+ * csi2_recv_config - CSI2 receiver module configuration.
+ * @currctrl: isp_csi2_ctrl_cfg structure
  *
- * It only saves settings when they were previously updated using the
- * isp_csi2_complexio_lanes_config() function, unless the force_update flag is
- * set to true.
- * Always returns 0.
- **/
-int isp_csi2_complexio_lanes_update(struct isp_csi2_device *isp_csi2,
-				    bool force_update)
+ */
+static void csi2_recv_config(struct isp_device *isp,
+			     struct isp_csi2_device *csi2,
+			     struct isp_csi2_ctrl_cfg *currctrl)
 {
-	struct isp_csi2_lanes_cfg *currlanes = &isp_csi2->current_cfg.lanes;
-	struct isp_csi2_lanes_cfg_update *currlanes_u =
-		&isp_csi2->current_cfg_update.lanes;
 	u32 reg;
-	int i;
-
-	if (!isp_csi2->update_complexio_cfg1 && !force_update)
-		return 0;
-
-	reg = isp_reg_readl(isp_csi2->dev, OMAP3_ISP_IOMEM_CSI2A,
-			    ISPCSI2_COMPLEXIO_CFG1);
-	for (i = 0; i < 4; i++) {
-		if (currlanes_u->data[i] || force_update) {
-			reg &= ~(ISPCSI2_COMPLEXIO_CFG1_DATA_POL_MASK(i + 1) |
-				 ISPCSI2_COMPLEXIO_CFG1_DATA_POSITION_MASK(i +
-									   1));
-			reg |= (currlanes->data[i].pol <<
-				ISPCSI2_COMPLEXIO_CFG1_DATA_POL_SHIFT(i + 1));
-			if (currlanes->data[i].state == ISP_CSI2_LANE_ON)
-				reg |= (currlanes->data[i].pos <<
-				ISPCSI2_COMPLEXIO_CFG1_DATA_POSITION_SHIFT(i +
-					1));
-			currlanes_u->data[i] = false;
-		}
-	}
 
-	if (currlanes_u->clk || force_update) {
-		reg &= ~(ISPCSI2_COMPLEXIO_CFG1_CLOCK_POL_MASK |
-			 ISPCSI2_COMPLEXIO_CFG1_CLOCK_POSITION_MASK);
-		reg |= (currlanes->clk.pol <<
-			ISPCSI2_COMPLEXIO_CFG1_CLOCK_POL_SHIFT);
-		reg |= (currlanes->clk.pos <<
-			ISPCSI2_COMPLEXIO_CFG1_CLOCK_POSITION_SHIFT);
-		currlanes_u->clk = false;
-	}
-	isp_reg_writel(isp_csi2->dev, reg, OMAP3_ISP_IOMEM_CSI2A,
-		       ISPCSI2_COMPLEXIO_CFG1);
+	reg = isp_reg_readl(isp, csi2->regs1, ISPCSI2_CTRL);
 
-	isp_csi2->update_complexio_cfg1 = false;
-	return 0;
-}
+	if (currctrl->frame_mode)
+		reg |= ISPCSI2_CTRL_FRAME;
+	else
+		reg &= ~ISPCSI2_CTRL_FRAME;
 
-/**
- * isp_csi2_complexio_lanes_count - Turn data lanes on/off dynamically.
- * @ cnt: Number of data lanes to enable.
- *
- * Always returns 0.
- **/
-int isp_csi2_complexio_lanes_count(struct isp_csi2_device *isp_csi2, int cnt)
-{
-	struct isp_csi2_lanes_cfg *currlanes = &isp_csi2->current_cfg.lanes;
-	int i;
+	if (currctrl->vp_clk_enable)
+		reg |= ISPCSI2_CTRL_VP_CLK_EN;
+	else
+		reg &= ~ISPCSI2_CTRL_VP_CLK_EN;
 
-	for (i = 0; i < 4; i++) {
-		if (i < cnt)
-			currlanes->data[i].state = ISP_CSI2_LANE_ON;
-		else
-			currlanes->data[i].state = ISP_CSI2_LANE_OFF;
-	}
+	if (currctrl->vp_only_enable)
+		reg |= ISPCSI2_CTRL_VP_ONLY_EN;
+	else
+		reg &= ~ISPCSI2_CTRL_VP_ONLY_EN;
 
-	isp_csi2_complexio_lanes_update(isp_csi2, true);
-	return 0;
-}
-EXPORT_SYMBOL(isp_csi2_complexio_lanes_count);
+	reg &= ~ISPCSI2_CTRL_VP_OUT_CTRL_MASK;
+	reg |= currctrl->vp_out_ctrl << ISPCSI2_CTRL_VP_OUT_CTRL_SHIFT;
 
-/**
- * isp_csi2_complexio_lanes_get - Gets CSI2 ComplexIO lanes configuration.
- *
- * Gets settings from HW registers and fills in the internal driver memory
- * Always returns 0.
- **/
-int isp_csi2_complexio_lanes_get(struct isp_csi2_device *isp_csi2)
-{
-	struct isp_csi2_lanes_cfg *currlanes = &isp_csi2->current_cfg.lanes;
-	struct isp_csi2_lanes_cfg_update *currlanes_u =
-		&isp_csi2->current_cfg_update.lanes;
-	u32 reg;
-	int i;
+	if (currctrl->ecc_enable)
+		reg |= ISPCSI2_CTRL_ECC_EN;
+	else
+		reg &= ~ISPCSI2_CTRL_ECC_EN;
 
-	reg = isp_reg_readl(isp_csi2->dev, OMAP3_ISP_IOMEM_CSI2A,
-			    ISPCSI2_COMPLEXIO_CFG1);
-	for (i = 0; i < 4; i++) {
-		currlanes->data[i].pol = (reg &
-					  ISPCSI2_COMPLEXIO_CFG1_DATA_POL_MASK(i + 1)) >>
-			ISPCSI2_COMPLEXIO_CFG1_DATA_POL_SHIFT(i + 1);
-		currlanes->data[i].pos = (reg &
-					  ISPCSI2_COMPLEXIO_CFG1_DATA_POSITION_MASK(i + 1)) >>
-			ISPCSI2_COMPLEXIO_CFG1_DATA_POSITION_SHIFT(i + 1);
-		currlanes_u->data[i] = false;
-	}
-	currlanes->clk.pol = (reg & ISPCSI2_COMPLEXIO_CFG1_CLOCK_POL_MASK) >>
-		ISPCSI2_COMPLEXIO_CFG1_CLOCK_POL_SHIFT;
-	currlanes->clk.pos = (reg &
-			      ISPCSI2_COMPLEXIO_CFG1_CLOCK_POSITION_MASK) >>
-		ISPCSI2_COMPLEXIO_CFG1_CLOCK_POSITION_SHIFT;
-	currlanes_u->clk = false;
-
-	isp_csi2->update_complexio_cfg1 = false;
-	return 0;
+	isp_reg_writel(isp, reg, csi2->regs1, ISPCSI2_CTRL);
 }
 
-/**
- * isp_csi2_complexio_power_status - Gets CSI2 ComplexIO power status.
- *
- * Returns 3 possible valid states: ISP_CSI2_POWER_OFF, ISP_CSI2_POWER_ON,
- * and ISP_CSI2_POWER_ULPW.
- **/
-static enum isp_csi2_power_cmds isp_csi2_complexio_power_status(
-					struct isp_csi2_device *isp_csi2)
-{
-	enum isp_csi2_power_cmds ret;
-	u32 reg;
-
-	reg = isp_reg_readl(isp_csi2->dev, OMAP3_ISP_IOMEM_CSI2A,
-			    ISPCSI2_COMPLEXIO_CFG1) &
-		ISPCSI2_COMPLEXIO_CFG1_PWR_STATUS_MASK;
-	switch (reg) {
-	case ISPCSI2_COMPLEXIO_CFG1_PWR_STATUS_OFF:
-		ret = ISP_CSI2_POWER_OFF;
-		break;
-	case ISPCSI2_COMPLEXIO_CFG1_PWR_STATUS_ON:
-		ret = ISP_CSI2_POWER_ON;
-		break;
-	case ISPCSI2_COMPLEXIO_CFG1_PWR_STATUS_ULPW:
-		ret = ISP_CSI2_POWER_ULPW;
-		break;
-	default:
-		return -EINVAL;
-	}
-	return ret;
-}
-
-/**
- * isp_csi2_complexio_power_autoswitch - Sets CSI2 ComplexIO power autoswitch.
- * @enable: Sets or clears the autoswitch function enable flag.
- *
- * Always returns 0.
- **/
-int isp_csi2_complexio_power_autoswitch(struct isp_csi2_device *isp_csi2,
-					bool enable)
-{
-	u32 reg;
-
-	reg = isp_reg_readl(isp_csi2->dev, OMAP3_ISP_IOMEM_CSI2A,
-			    ISPCSI2_COMPLEXIO_CFG1);
-	reg &= ~ISPCSI2_COMPLEXIO_CFG1_PWR_AUTO_MASK;
-
-	if (enable)
-		reg |= ISPCSI2_COMPLEXIO_CFG1_PWR_AUTO_ENABLE;
-	else
-		reg |= ISPCSI2_COMPLEXIO_CFG1_PWR_AUTO_DISABLE;
+static const unsigned int csi2_input_fmts[] = {
+	V4L2_MBUS_FMT_SGRBG10_1X10,
+	V4L2_MBUS_FMT_SGRBG10_DPCM8_1X8,
+	V4L2_MBUS_FMT_SRGGB10_1X10,
+	V4L2_MBUS_FMT_SRGGB10_DPCM8_1X8,
+	V4L2_MBUS_FMT_SBGGR10_1X10,
+	V4L2_MBUS_FMT_SBGGR10_DPCM8_1X8,
+	V4L2_MBUS_FMT_SGBRG10_1X10,
+	V4L2_MBUS_FMT_SGBRG10_DPCM8_1X8,
+	V4L2_MBUS_FMT_YUYV8_2X8,
+};
 
-	isp_reg_writel(isp_csi2->dev, reg, OMAP3_ISP_IOMEM_CSI2A,
-		       ISPCSI2_COMPLEXIO_CFG1);
-	return 0;
-}
+/* To set the format on the CSI2 requires a mapping function that takes
+ * the following inputs:
+ * - 3 different formats (at this time)
+ * - 2 destinations (mem, vp+mem) (vp only handled separately)
+ * - 2 decompression options (on, off)
+ * - 2 isp revisions (certain format must be handled differently on OMAP3630)
+ * Output should be CSI2 frame format code
+ * Array indices as follows: [format][dest][decompr][is_3630]
+ * Not all combinations are valid. 0 means invalid.
+ */
+static const u16 __csi2_fmt_map[3][2][2][2] = {
+	/* RAW10 formats */
+	{
+		/* Output to memory */
+		{
+			/* No DPCM decompression */
+			{ CSI2_PIX_FMT_RAW10_EXP16, CSI2_PIX_FMT_RAW10_EXP16 },
+			/* DPCM decompression */
+			{ 0, 0 },
+		},
+		/* Output to both */
+		{
+			/* No DPCM decompression */
+			{ CSI2_PIX_FMT_RAW10_EXP16_VP,
+			  CSI2_PIX_FMT_RAW10_EXP16_VP },
+			/* DPCM decompression */
+			{ 0, 0 },
+		},
+	},
+	/* RAW10 DPCM8 formats */
+	{
+		/* Output to memory */
+		{
+			/* No DPCM decompression */
+			{ CSI2_PIX_FMT_RAW8, CSI2_USERDEF_8BIT_DATA1 },
+			/* DPCM decompression */
+			{ CSI2_PIX_FMT_RAW8_DPCM10_EXP16,
+			  CSI2_USERDEF_8BIT_DATA1_DPCM10 },
+		},
+		/* Output to both */
+		{
+			/* No DPCM decompression */
+			{ CSI2_PIX_FMT_RAW8_VP,
+			  CSI2_PIX_FMT_RAW8_VP },
+			/* DPCM decompression */
+			{ CSI2_PIX_FMT_RAW8_DPCM10_VP,
+			  CSI2_USERDEF_8BIT_DATA1_DPCM10_VP },
+		},
+	},
+	/* YUYV8 2X8 formats */
+	{
+		/* Output to memory */
+		{
+			/* No DPCM decompression */
+			{ CSI2_PIX_FMT_YUV422_8BIT,
+			  CSI2_PIX_FMT_YUV422_8BIT },
+			/* DPCM decompression */
+			{ CSI2_PIX_FMT_YUV422_8BIT,
+			  CSI2_PIX_FMT_YUV422_8BIT },
+		},
+		/* Output to both */
+		{
+			/* No DPCM decompression */
+			{ CSI2_PIX_FMT_YUV422_8BIT_VP,
+			  CSI2_PIX_FMT_YUV422_8BIT_VP },
+			/* DPCM decompression */
+			{ CSI2_PIX_FMT_YUV422_8BIT_VP,
+			  CSI2_PIX_FMT_YUV422_8BIT_VP },
+		},
+	},
+};
 
-/**
- * isp_csi2_complexio_power - Sets the desired power command for CSI2 ComplexIO.
- * @power_cmd: Power command to be set.
+/*
+ * csi2_ctx_map_format - Map CSI2 sink media bus format to CSI2 format ID
+ * @csi2: ISP CSI2 device
  *
- * Returns 0 if successful, or -EBUSY if the retry count is exceeded.
- **/
-int isp_csi2_complexio_power(struct isp_csi2_device *isp_csi2,
-			     enum isp_csi2_power_cmds power_cmd)
+ * Returns CSI2 physical format id
+ */
+static u16 csi2_ctx_map_format(struct isp_csi2_device *csi2)
 {
-	enum isp_csi2_power_cmds current_state;
-	u32 reg;
-	u8 retry_count;
-
-	reg = isp_reg_readl(isp_csi2->dev, OMAP3_ISP_IOMEM_CSI2A,
-			    ISPCSI2_COMPLEXIO_CFG1) &
-		~ISPCSI2_COMPLEXIO_CFG1_PWR_CMD_MASK;
-	switch (power_cmd) {
-	case ISP_CSI2_POWER_OFF:
-		reg |= ISPCSI2_COMPLEXIO_CFG1_PWR_CMD_OFF;
+	const struct v4l2_mbus_framefmt *fmt = &csi2->formats[CSI2_PAD_SINK];
+	int fmtidx, destidx, is_3630;
+
+	switch (fmt->code) {
+	case V4L2_MBUS_FMT_SGRBG10_1X10:
+	case V4L2_MBUS_FMT_SRGGB10_1X10:
+	case V4L2_MBUS_FMT_SBGGR10_1X10:
+	case V4L2_MBUS_FMT_SGBRG10_1X10:
+		fmtidx = 0;
 		break;
-	case ISP_CSI2_POWER_ON:
-		reg |= ISPCSI2_COMPLEXIO_CFG1_PWR_CMD_ON;
+	case V4L2_MBUS_FMT_SGRBG10_DPCM8_1X8:
+	case V4L2_MBUS_FMT_SRGGB10_DPCM8_1X8:
+	case V4L2_MBUS_FMT_SBGGR10_DPCM8_1X8:
+	case V4L2_MBUS_FMT_SGBRG10_DPCM8_1X8:
+		fmtidx = 1;
 		break;
-	case ISP_CSI2_POWER_ULPW:
-		reg |= ISPCSI2_COMPLEXIO_CFG1_PWR_CMD_ULPW;
+	case V4L2_MBUS_FMT_YUYV8_2X8:
+		fmtidx = 2;
 		break;
 	default:
-		printk(KERN_ERR "CSI2: ERROR - Wrong Power command!\n");
-		return -EINVAL;
+		WARN(1, KERN_ERR "CSI2: pixel format %08x unsupported!\n",
+		     fmt->code);
+		return 0;
 	}
-	isp_reg_writel(isp_csi2->dev, reg, OMAP3_ISP_IOMEM_CSI2A,
-		       ISPCSI2_COMPLEXIO_CFG1);
 
-	retry_count = 0;
-	do {
-		udelay(50);
-		current_state = isp_csi2_complexio_power_status(isp_csi2);
-
-		if (current_state != power_cmd) {
-			printk(KERN_DEBUG "CSI2: Complex IO power command not"
-			       " yet taken.");
-			if (++retry_count < 100) {
-				printk(KERN_DEBUG " Retrying...\n");
-				udelay(50);
-			} else {
-				printk(KERN_DEBUG " Retry count exceeded!\n");
-			}
-		}
-	} while ((current_state != power_cmd) && (retry_count < 100));
-
-	if (retry_count == 100)
-		return -EBUSY;
-
-	return 0;
-}
-
-/**
- * isp_csi2_ctrl_config_frame_mode - Configure if_en behaviour for CSI2
- * @frame_mode: Desired action for IF_EN switch off. 0 - disable IF immediately
- *              1 - disable after all Frame end Code is received in all
- *              contexts.
- *
- * Validates and saves to internal driver memory the passed configuration.
- * Always returns 0.
- **/
-int isp_csi2_ctrl_config_frame_mode(struct isp_csi2_device *isp_csi2,
-				    enum isp_csi2_frame_mode frame_mode)
-{
-	struct isp_csi2_ctrl_cfg *currctrl = &isp_csi2->current_cfg.ctrl;
-	struct isp_csi2_ctrl_cfg_update *currctrl_u =
-		&isp_csi2->current_cfg_update.ctrl;
-
-	if (currctrl->frame_mode != frame_mode) {
-		currctrl->frame_mode = frame_mode;
-		currctrl_u->frame_mode = true;
-		isp_csi2->update_ctrl = true;
+	if (!(csi2->output & CSI2_OUTPUT_CCDC) &&
+	    !(csi2->output & CSI2_OUTPUT_MEMORY)) {
+		/* Neither output enabled is a valid combination */
+		return CSI2_PIX_FMT_OTHERS;
 	}
-	return 0;
-}
 
-/**
- * isp_csi2_ctrl_config_vp_clk_enable - Enables/disables CSI2 Videoport clock.
- * @vp_clk_enable: Boolean value to specify the Videoport clock state.
- *
- * Validates and saves to internal driver memory the passed configuration.
- * Always returns 0.
- **/
-int isp_csi2_ctrl_config_vp_clk_enable(struct isp_csi2_device *isp_csi2,
-				       bool vp_clk_enable)
-{
-	struct isp_csi2_ctrl_cfg *currctrl = &isp_csi2->current_cfg.ctrl;
-	struct isp_csi2_ctrl_cfg_update *currctrl_u =
-		&isp_csi2->current_cfg_update.ctrl;
-
-	if (currctrl->vp_clk_enable != vp_clk_enable) {
-		currctrl->vp_clk_enable = vp_clk_enable;
-		currctrl_u->vp_clk_enable = true;
-		isp_csi2->update_ctrl = true;
-	}
-	return 0;
-}
+	/* If we need to skip frames at the beginning of the stream disable the
+	 * video port to avoid sending the skipped frames to the CCDC.
+	 */
+	destidx = csi2->frame_skip ? 0 : !!(csi2->output & CSI2_OUTPUT_CCDC);
+	is_3630 = csi2->isp->revision == ISP_REVISION_15_0;
 
-/**
- * isp_csi2_ctrl_config_vp_only_enable - Sets CSI2 Videoport clock as exclusive
- * @vp_only_enable: Boolean value to specify if the Videoport clock is
- *                  exclusive, setting the OCP port as disabled.
- *
- * Validates and saves to internal driver memory the passed configuration.
- * Always returns 0.
- **/
-int isp_csi2_ctrl_config_vp_only_enable(struct isp_csi2_device *isp_csi2,
-					bool vp_only_enable)
-{
-	struct isp_csi2_ctrl_cfg *currctrl = &isp_csi2->current_cfg.ctrl;
-	struct isp_csi2_ctrl_cfg_update *currctrl_u =
-		&isp_csi2->current_cfg_update.ctrl;
-
-	if (currctrl->vp_only_enable != vp_only_enable) {
-		currctrl->vp_only_enable = vp_only_enable;
-		currctrl_u->vp_only_enable = true;
-		isp_csi2->update_ctrl = true;
-	}
-	return 0;
+	return __csi2_fmt_map[fmtidx][destidx][csi2->dpcm_decompress][is_3630];
 }
 
-/**
- * isp_csi2_ctrl_config_vp_out_ctrl - Sets CSI2 Videoport clock divider
- * @vp_out_ctrl: Divider value for setting videoport clock frequency based on
- *               OCP port frequency, valid dividers are between 1 and 4.
+/*
+ * csi2_set_outaddr - Set memory address to save output image
+ * @csi2: Pointer to ISP CSI2a device.
+ * @addr: ISP MMU Mapped 32-bit memory address aligned on 32 byte boundary.
  *
- * Validates and saves to internal driver memory the passed configuration.
- * Returns 0 if successful, or -EINVAL if wrong divider value is passed.
- **/
-int isp_csi2_ctrl_config_vp_out_ctrl(struct isp_csi2_device *isp_csi2,
-				     u8 vp_out_ctrl)
-{
-	struct isp_csi2_ctrl_cfg *currctrl = &isp_csi2->current_cfg.ctrl;
-	struct isp_csi2_ctrl_cfg_update *currctrl_u =
-		&isp_csi2->current_cfg_update.ctrl;
-
-	if ((vp_out_ctrl == 0) || (vp_out_ctrl > 4)) {
-		printk(KERN_ERR "CSI2: Wrong divisor value. Must be between"
-		       " 1 and 4");
-		return -EINVAL;
-	}
-
-	if (currctrl->vp_out_ctrl != vp_out_ctrl) {
-		currctrl->vp_out_ctrl = vp_out_ctrl;
-		currctrl_u->vp_out_ctrl = true;
-		isp_csi2->update_ctrl = true;
-	}
-	return 0;
-}
-
-/**
- * isp_csi2_ctrl_config_debug_enable - Sets CSI2 debug
- * @debug_enable: Boolean for setting debug configuration on CSI2.
+ * Sets the memory address where the output will be saved.
  *
- * Always returns 0.
- **/
-int isp_csi2_ctrl_config_debug_enable(struct isp_csi2_device *isp_csi2,
-				      bool debug_enable)
+ * Returns 0 if successful, or -EINVAL if the address is not in the 32 byte
+ * boundary.
+ */
+static void csi2_set_outaddr(struct isp_csi2_device *csi2, u32 addr)
 {
-	struct isp_csi2_ctrl_cfg *currctrl = &isp_csi2->current_cfg.ctrl;
-	struct isp_csi2_ctrl_cfg_update *currctrl_u =
-		&isp_csi2->current_cfg_update.ctrl;
-
-	if (currctrl->debug_enable != debug_enable) {
-		currctrl->debug_enable = debug_enable;
-		currctrl_u->debug_enable = true;
-		isp_csi2->update_ctrl = true;
-	}
-	return 0;
+	struct isp_device *isp = csi2->isp;
+	struct isp_csi2_ctx_cfg *ctx = &csi2->contexts[0];
+
+	ctx->ping_addr = addr;
+	ctx->pong_addr = addr;
+	isp_reg_writel(isp, ctx->ping_addr,
+		       csi2->regs1, ISPCSI2_CTX_DAT_PING_ADDR(ctx->ctxnum));
+	isp_reg_writel(isp, ctx->pong_addr,
+		       csi2->regs1, ISPCSI2_CTX_DAT_PONG_ADDR(ctx->ctxnum));
 }
 
-/**
- * isp_csi2_ctrl_config_burst_size - Sets CSI2 burst size.
- * @burst_size: Burst size of the memory saving capability of receiver.
+/*
+ * is_usr_def_mapping - Checks whether USER_DEF_MAPPING should
+ *			be enabled by CSI2.
+ * @format_id: mapped format id
  *
- * Returns 0 if successful, or -EINVAL if burst size is wrong.
- **/
-int isp_csi2_ctrl_config_burst_size(struct isp_csi2_device *isp_csi2,
-				    u8 burst_size)
+ */
+static inline int is_usr_def_mapping(u32 format_id)
 {
-	struct isp_csi2_ctrl_cfg *currctrl = &isp_csi2->current_cfg.ctrl;
-	struct isp_csi2_ctrl_cfg_update *currctrl_u =
-		&isp_csi2->current_cfg_update.ctrl;
-	if (burst_size > 3) {
-		printk(KERN_ERR "CSI2: Wrong burst size. Must be between"
-		       " 0 and 3");
-		return -EINVAL;
-	}
-
-	if (currctrl->burst_size != burst_size) {
-		currctrl->burst_size = burst_size;
-		currctrl_u->burst_size = true;
-		isp_csi2->update_ctrl = true;
-	}
-	return 0;
+	return (format_id & 0x40) ? 1 : 0;
 }
 
-/**
- * isp_csi2_ctrl_config_ecc_enable - Enables ECC on CSI2 Receiver
- * @ecc_enable: Boolean to enable/disable the CSI2 receiver ECC handling.
+/*
+ * csi2_ctx_enable - Enable specified CSI2 context
+ * @ctxnum: Context number, valid between 0 and 7 values.
+ * @enable: enable
  *
- * Always returns 0.
- **/
-int isp_csi2_ctrl_config_ecc_enable(struct isp_csi2_device *isp_csi2,
-				    bool ecc_enable)
+ */
+static void csi2_ctx_enable(struct isp_device *isp,
+			    struct isp_csi2_device *csi2, u8 ctxnum, u8 enable)
 {
-	struct isp_csi2_ctrl_cfg *currctrl = &isp_csi2->current_cfg.ctrl;
-	struct isp_csi2_ctrl_cfg_update *currctrl_u =
-		&isp_csi2->current_cfg_update.ctrl;
-
-	if (currctrl->ecc_enable != ecc_enable) {
-		currctrl->ecc_enable = ecc_enable;
-		currctrl_u->ecc_enable = true;
-		isp_csi2->update_ctrl = true;
-	}
-	return 0;
-}
+	struct isp_csi2_ctx_cfg *ctx = &csi2->contexts[ctxnum];
+	unsigned int skip = 0;
+	u32 reg;
 
-/**
- * isp_csi2_ctrl_config_ecc_enable - Enables ECC on CSI2 Receiver
- * @ecc_enable: Boolean to enable/disable the CSI2 receiver ECC handling.
- *
- * Always returns 0.
- **/
-int isp_csi2_ctrl_config_secure_mode(struct isp_csi2_device *isp_csi2,
-				     bool secure_mode)
-{
-	struct isp_csi2_ctrl_cfg *currctrl = &isp_csi2->current_cfg.ctrl;
-	struct isp_csi2_ctrl_cfg_update *currctrl_u =
-		&isp_csi2->current_cfg_update.ctrl;
-
-	if (currctrl->secure_mode != secure_mode) {
-		currctrl->secure_mode = secure_mode;
-		currctrl_u->secure_mode = true;
-		isp_csi2->update_ctrl = true;
-	}
-	return 0;
-}
+	reg = isp_reg_readl(isp, csi2->regs1, ISPCSI2_CTX_CTRL1(ctxnum));
 
-/**
- * isp_csi2_ctrl_config_if_enable - Enables CSI2 Receiver interface.
- * @if_enable: Boolean to enable/disable the CSI2 receiver interface.
- *
- * Always returns 0.
- **/
-int isp_csi2_ctrl_config_if_enable(struct isp_csi2_device *isp_csi2,
-				   bool if_enable)
-{
-	struct isp_csi2_ctrl_cfg *currctrl = &isp_csi2->current_cfg.ctrl;
-	struct isp_csi2_ctrl_cfg_update *currctrl_u =
-		&isp_csi2->current_cfg_update.ctrl;
-
-	if (currctrl->if_enable != if_enable) {
-		currctrl->if_enable = if_enable;
-		currctrl_u->if_enable = true;
-		isp_csi2->update_ctrl = true;
+	if (enable) {
+		if (csi2->frame_skip)
+			skip = csi2->frame_skip;
+		else if (csi2->output & CSI2_OUTPUT_MEMORY)
+			skip = 1;
+
+		reg &= ~ISPCSI2_CTX_CTRL1_COUNT_MASK;
+		reg |= ISPCSI2_CTX_CTRL1_COUNT_UNLOCK
+		    |  (skip << ISPCSI2_CTX_CTRL1_COUNT_SHIFT)
+		    |  ISPCSI2_CTX_CTRL1_CTX_EN;
+	} else {
+		reg &= ~ISPCSI2_CTX_CTRL1_CTX_EN;
 	}
-	return 0;
-}
 
-/**
- * isp_csi2_ctrl_update - Applies CSI2 control configuration.
- * @force_update: Flag to force rewrite of registers, even if they haven't been
- *                updated with the isp_csi2_ctrl_config_*() functions.
- *
- * It only saves settings when they were previously updated using the
- * isp_csi2_ctrl_config_*() functions, unless the force_update flag is
- * set to true.
- * Always returns 0.
- **/
-int isp_csi2_ctrl_update(struct isp_csi2_device *isp_csi2, bool force_update)
-{
-	struct isp_csi2_ctrl_cfg *currctrl = &isp_csi2->current_cfg.ctrl;
-	struct isp_csi2_ctrl_cfg_update *currctrl_u =
-		&isp_csi2->current_cfg_update.ctrl;
-	u32 reg;
-
-	if (isp_csi2->update_ctrl || force_update) {
-		reg = isp_reg_readl(isp_csi2->dev, OMAP3_ISP_IOMEM_CSI2A,
-				    ISPCSI2_CTRL);
-		if (currctrl_u->frame_mode || force_update) {
-			reg &= ~ISPCSI2_CTRL_FRAME_MASK;
-			if (currctrl->frame_mode)
-				reg |= ISPCSI2_CTRL_FRAME_DISABLE_FEC;
-			else
-				reg |= ISPCSI2_CTRL_FRAME_DISABLE_IMM;
-			currctrl_u->frame_mode = false;
-		}
-		if (currctrl_u->vp_clk_enable || force_update) {
-			reg &= ~ISPCSI2_CTRL_VP_CLK_EN_MASK;
-			if (currctrl->vp_clk_enable)
-				reg |= ISPCSI2_CTRL_VP_CLK_EN_ENABLE;
-			else
-				reg |= ISPCSI2_CTRL_VP_CLK_EN_DISABLE;
-			currctrl_u->vp_clk_enable = false;
-		}
-		if (currctrl_u->vp_only_enable || force_update) {
-			reg &= ~ISPCSI2_CTRL_VP_ONLY_EN_MASK;
-			isp_csi2->uses_videoport = currctrl->vp_only_enable;
-			if (currctrl->vp_only_enable)
-				reg |= ISPCSI2_CTRL_VP_ONLY_EN_ENABLE;
-			else
-				reg |= ISPCSI2_CTRL_VP_ONLY_EN_DISABLE;
-			currctrl_u->vp_only_enable = false;
-		}
-		if (currctrl_u->vp_out_ctrl || force_update) {
-			reg &= ~ISPCSI2_CTRL_VP_OUT_CTRL_MASK;
-			reg |= (currctrl->vp_out_ctrl - 1) <<
-				ISPCSI2_CTRL_VP_OUT_CTRL_SHIFT;
-			currctrl_u->vp_out_ctrl = false;
-		}
-		if (currctrl_u->debug_enable || force_update) {
-			reg &= ~ISPCSI2_CTRL_DBG_EN_MASK;
-			if (currctrl->debug_enable)
-				reg |= ISPCSI2_CTRL_DBG_EN_ENABLE;
-			else
-				reg |= ISPCSI2_CTRL_DBG_EN_DISABLE;
-			currctrl_u->debug_enable = false;
-		}
-		if (currctrl_u->burst_size || force_update) {
-			reg &= ~ISPCSI2_CTRL_BURST_SIZE_MASK;
-			reg |= currctrl->burst_size <<
-				ISPCSI2_CTRL_BURST_SIZE_SHIFT;
-			currctrl_u->burst_size = false;
-		}
-		if (currctrl_u->ecc_enable || force_update) {
-			reg &= ~ISPCSI2_CTRL_ECC_EN_MASK;
-			if (currctrl->ecc_enable)
-				reg |= ISPCSI2_CTRL_ECC_EN_ENABLE;
-			else
-				reg |= ISPCSI2_CTRL_ECC_EN_DISABLE;
-			currctrl_u->ecc_enable = false;
-		}
-		if (currctrl_u->secure_mode || force_update) {
-			reg &= ~ISPCSI2_CTRL_SECURE_MASK;
-			if (currctrl->secure_mode)
-				reg |= ISPCSI2_CTRL_SECURE_ENABLE;
-			else
-				reg |= ISPCSI2_CTRL_SECURE_DISABLE;
-			currctrl_u->secure_mode = false;
-		}
-		if (currctrl_u->if_enable || force_update) {
-			reg &= ~ISPCSI2_CTRL_IF_EN_MASK;
-			if (currctrl->if_enable)
-				reg |= ISPCSI2_CTRL_IF_EN_ENABLE;
-			else
-				reg |= ISPCSI2_CTRL_IF_EN_DISABLE;
-			currctrl_u->if_enable = false;
-		}
-		isp_reg_writel(isp_csi2->dev, reg, OMAP3_ISP_IOMEM_CSI2A,
-			       ISPCSI2_CTRL);
-		isp_csi2->update_ctrl = false;
-	}
-	return 0;
+	isp_reg_writel(isp, reg, csi2->regs1, ISPCSI2_CTX_CTRL1(ctxnum));
+	ctx->enabled = enable;
 }
 
-/**
- * isp_csi2_ctrl_get - Gets CSI2 control configuration
+/*
+ * csi2_ctx_config - CSI2 context configuration.
+ * @ctx: context configuration
  *
- * Always returns 0.
- **/
-int isp_csi2_ctrl_get(struct isp_csi2_device *isp_csi2)
+ */
+static void csi2_ctx_config(struct isp_device *isp,
+			    struct isp_csi2_device *csi2,
+			    struct isp_csi2_ctx_cfg *ctx)
 {
-	struct isp_csi2_ctrl_cfg *currctrl = &isp_csi2->current_cfg.ctrl;
-	struct isp_csi2_ctrl_cfg_update *currctrl_u =
-		&isp_csi2->current_cfg_update.ctrl;
 	u32 reg;
 
-	reg = isp_reg_readl(isp_csi2->dev, OMAP3_ISP_IOMEM_CSI2A,
-			    ISPCSI2_CTRL);
-	currctrl->frame_mode = (reg & ISPCSI2_CTRL_FRAME_MASK) >>
-		ISPCSI2_CTRL_FRAME_SHIFT;
-	currctrl_u->frame_mode = false;
+	/* Set up CSI2_CTx_CTRL1 */
+	reg = isp_reg_readl(isp, csi2->regs1, ISPCSI2_CTX_CTRL1(ctx->ctxnum));
 
-	if ((reg & ISPCSI2_CTRL_VP_CLK_EN_MASK) ==
-	    ISPCSI2_CTRL_VP_CLK_EN_ENABLE)
-		currctrl->vp_clk_enable = true;
+	if (ctx->eof_enabled)
+		reg |= ISPCSI2_CTX_CTRL1_EOF_EN;
 	else
-		currctrl->vp_clk_enable = false;
-	currctrl_u->vp_clk_enable = false;
+		reg &= ~ISPCSI2_CTX_CTRL1_EOF_EN;
 
-	if ((reg & ISPCSI2_CTRL_VP_ONLY_EN_MASK) ==
-	    ISPCSI2_CTRL_VP_ONLY_EN_ENABLE)
-		currctrl->vp_only_enable = true;
+	if (ctx->eol_enabled)
+		reg |= ISPCSI2_CTX_CTRL1_EOL_EN;
 	else
-		currctrl->vp_only_enable = false;
-	isp_csi2->uses_videoport = currctrl->vp_only_enable;
-	currctrl_u->vp_only_enable = false;
+		reg &= ~ISPCSI2_CTX_CTRL1_EOL_EN;
 
-	currctrl->vp_out_ctrl = ((reg & ISPCSI2_CTRL_VP_OUT_CTRL_MASK) >>
-				 ISPCSI2_CTRL_VP_OUT_CTRL_SHIFT) + 1;
-	currctrl_u->vp_out_ctrl = false;
-
-	if ((reg & ISPCSI2_CTRL_DBG_EN_MASK) == ISPCSI2_CTRL_DBG_EN_ENABLE)
-		currctrl->debug_enable = true;
+	if (ctx->checksum_enabled)
+		reg |= ISPCSI2_CTX_CTRL1_CS_EN;
 	else
-		currctrl->debug_enable = false;
-	currctrl_u->debug_enable = false;
+		reg &= ~ISPCSI2_CTX_CTRL1_CS_EN;
 
-	currctrl->burst_size = (reg & ISPCSI2_CTRL_BURST_SIZE_MASK) >>
-		ISPCSI2_CTRL_BURST_SIZE_SHIFT;
-	currctrl_u->burst_size = false;
+	isp_reg_writel(isp, reg, csi2->regs1, ISPCSI2_CTX_CTRL1(ctx->ctxnum));
 
-	if ((reg & ISPCSI2_CTRL_ECC_EN_MASK) == ISPCSI2_CTRL_ECC_EN_ENABLE)
-		currctrl->ecc_enable = true;
-	else
-		currctrl->ecc_enable = false;
-	currctrl_u->ecc_enable = false;
+	/* Set up CSI2_CTx_CTRL2 */
+	reg = isp_reg_readl(isp, csi2->regs1, ISPCSI2_CTX_CTRL2(ctx->ctxnum));
 
-	if ((reg & ISPCSI2_CTRL_SECURE_MASK) == ISPCSI2_CTRL_SECURE_ENABLE)
-		currctrl->secure_mode = true;
-	else
-		currctrl->secure_mode = false;
-	currctrl_u->secure_mode = false;
+	reg &= ~(ISPCSI2_CTX_CTRL2_VIRTUAL_ID_MASK);
+	reg |= ctx->virtual_id << ISPCSI2_CTX_CTRL2_VIRTUAL_ID_SHIFT;
 
-	if ((reg & ISPCSI2_CTRL_IF_EN_MASK) == ISPCSI2_CTRL_IF_EN_ENABLE)
-		currctrl->if_enable = true;
-	else
-		currctrl->if_enable = false;
-	currctrl_u->if_enable = false;
-
-	isp_csi2->update_ctrl = false;
-	return 0;
-}
-
-/**
- * isp_csi2_ctx_validate - Validates the context number value
- * @ctxnum: Pointer to variable containing context number.
- *
- * If the value is not in range (3 bits), it is being ANDed with 0x7 to force
- * it to be on range.
- **/
-static void isp_csi2_ctx_validate(u8 *ctxnum)
-{
-	if (*ctxnum > 7) {
-		printk(KERN_ERR "Invalid context number. Forcing valid"
-		       " value...\n");
-		*ctxnum &= ~(0x7);
-	}
-}
-
-/**
- * isp_csi2_ctx_config_virtual_id - Maps a virtual ID with a CSI2 Rx context
- * @ctxnum: Context number, valid between 0 and 7 values.
- * @virtual_id: CSI2 Virtual ID to associate with specified context number.
- *
- * Returns 0 if successful, or -EINVAL if Virtual ID is not in range (0-3).
- **/
-int isp_csi2_ctx_config_virtual_id(struct isp_csi2_device *isp_csi2, u8 ctxnum,
-				   u8 virtual_id)
-{
-	struct isp_csi2_ctx_cfg *selected_ctx;
-	struct isp_csi2_ctx_cfg_update *selected_ctx_u;
-
-	isp_csi2_ctx_validate(&ctxnum);
-
-	if (virtual_id > 3) {
-		printk(KERN_ERR "Wrong requested virtual_id\n");
-		return -EINVAL;
-	}
-
-	selected_ctx = &isp_csi2->current_cfg.contexts[ctxnum];
-	selected_ctx_u = &isp_csi2->current_cfg_update.contexts[ctxnum];
-
-	if (selected_ctx->virtual_id != virtual_id) {
-		selected_ctx->virtual_id = virtual_id;
-		selected_ctx_u->virtual_id = true;
-		isp_csi2->update_ctx_ctrl2[ctxnum] = true;
-	}
-
-	return 0;
-}
-
-/**
- * isp_csi2_ctx_config_frame_count - Sets frame count to be received in CSI2 Rx.
- * @ctxnum: Context number, valid between 0 and 7 values.
- * @frame_count: Number of frames to acquire.
- *
- * Always returns 0.
- **/
-int isp_csi2_ctx_config_frame_count(struct isp_csi2_device *isp_csi2, u8 ctxnum,
-				    u8 frame_count)
-{
-	struct isp_csi2_ctx_cfg *selected_ctx;
-	struct isp_csi2_ctx_cfg_update *selected_ctx_u;
-
-	isp_csi2_ctx_validate(&ctxnum);
-
-	selected_ctx = &isp_csi2->current_cfg.contexts[ctxnum];
-	selected_ctx_u = &isp_csi2->current_cfg_update.contexts[ctxnum];
-
-	if (selected_ctx->frame_count != frame_count) {
-		selected_ctx->frame_count = frame_count;
-		selected_ctx_u->frame_count = true;
-		isp_csi2->update_ctx_ctrl1[ctxnum] = true;
-	}
-
-	return 0;
-}
-
-/**
- * isp_csi2_ctx_config_format - Maps a pixel format to a specified context.
- * @ctxnum: Context number, valid between 0 and 7 values.
- * @pixformat: V4L2 structure for pixel format.
- *
- * Returns 0 if successful, or -EINVAL if the format is not supported by the
- * receiver.
- **/
-int isp_csi2_ctx_config_format(struct isp_csi2_device *isp_csi2, u8 ctxnum,
-			       u32 pixformat)
-{
-	struct isp_csi2_ctx_cfg *selected_ctx;
-	struct isp_csi2_ctx_cfg_update *selected_ctx_u;
-	struct v4l2_pix_format pix;
-
-	isp_csi2_ctx_validate(&ctxnum);
-
-	pix.pixelformat = pixformat;
-	switch (pix.pixelformat) {
-	case V4L2_PIX_FMT_RGB565:
-	case V4L2_PIX_FMT_RGB565X:
-	case V4L2_PIX_FMT_YUYV:
-	case V4L2_PIX_FMT_UYVY:
-	case V4L2_PIX_FMT_RGB555:
-	case V4L2_PIX_FMT_RGB555X:
-	case V4L2_PIX_FMT_SGRBG10:
-	case V4L2_PIX_FMT_SRGGB10:
-	case V4L2_PIX_FMT_SBGGR10:
-	case V4L2_PIX_FMT_SGBRG10:
-		break;
-	default:
-		printk(KERN_ERR "Context config pixel format unsupported\n");
-		return -EINVAL;
-	}
-
-	selected_ctx = &isp_csi2->current_cfg.contexts[ctxnum];
-	selected_ctx_u = &isp_csi2->current_cfg_update.contexts[ctxnum];
-
-	selected_ctx->format = pix;
-	selected_ctx_u->format = true;
-	isp_csi2->update_ctx_ctrl2[ctxnum] = true;
-
-	return 0;
-}
-
-/**
- * isp_csi2_ctx_config_alpha - Sets the alpha value for pixel format
- * @ctxnum: Context number, valid between 0 and 7 values.
- * @alpha: Alpha value.
- *
- * Returns 0 if successful, or -EINVAL if the alpha value is bigger than 16383.
- **/
-int isp_csi2_ctx_config_alpha(struct isp_csi2_device *isp_csi2, u8 ctxnum,
-			      u16 alpha)
-{
-	struct isp_csi2_ctx_cfg *selected_ctx;
-	struct isp_csi2_ctx_cfg_update *selected_ctx_u;
+	reg &= ~(ISPCSI2_CTX_CTRL2_FORMAT_MASK);
+	reg |= ctx->format_id << ISPCSI2_CTX_CTRL2_FORMAT_SHIFT;
 
-	isp_csi2_ctx_validate(&ctxnum);
-
-	if (alpha > 0x3FFF) {
-		printk(KERN_ERR "Wrong alpha value\n");
-		return -EINVAL;
-	}
-
-	selected_ctx = &isp_csi2->current_cfg.contexts[ctxnum];
-	selected_ctx_u = &isp_csi2->current_cfg_update.contexts[ctxnum];
-
-	if (selected_ctx->alpha != alpha) {
-		selected_ctx->alpha = alpha;
-		selected_ctx_u->alpha = true;
-		isp_csi2->update_ctx_ctrl3[ctxnum] = true;
-	}
-	return 0;
-}
-
-/**
- * isp_csi2_ctx_config_data_offset - Sets the offset between received lines
- * @ctxnum: Context number, valid between 0 and 7 values.
- * @data_offset: Offset between first pixel of each 2 contiguous lines.
- *
- * Returns 0 if successful, or -EINVAL if the line offset is bigger than 1023.
- **/
-int isp_csi2_ctx_config_data_offset(struct isp_csi2_device *isp_csi2,
-				    u8 ctxnum, u16 data_offset)
-{
-	struct isp_csi2_ctx_cfg *selected_ctx;
-	struct isp_csi2_ctx_cfg_update *selected_ctx_u;
-
-	isp_csi2_ctx_validate(&ctxnum);
-
-	if (data_offset > 0x3FF) {
-		printk(KERN_ERR "Wrong line offset\n");
-		return -EINVAL;
-	}
-
-	selected_ctx = &isp_csi2->current_cfg.contexts[ctxnum];
-	selected_ctx_u = &isp_csi2->current_cfg_update.contexts[ctxnum];
-
-	if (selected_ctx->data_offset != data_offset) {
-		selected_ctx->data_offset = data_offset;
-		selected_ctx_u->data_offset = true;
+	if (ctx->dpcm_decompress) {
+		if (ctx->dpcm_predictor)
+			reg |= ISPCSI2_CTX_CTRL2_DPCM_PRED;
+		else
+			reg &= ~ISPCSI2_CTX_CTRL2_DPCM_PRED;
 	}
-	return 0;
-}
-
-/**
- * isp_csi2_ctx_config_ping_addr - Sets Ping address for CSI2 Rx. buffer saving
- * @ctxnum: Context number, valid between 0 and 7 values.
- * @ping_addr: 32 bit ISP MMU mapped address.
- *
- * Always returns 0.
- **/
-int isp_csi2_ctx_config_ping_addr(struct isp_csi2_device *isp_csi2,
-				  u8 ctxnum, u32 ping_addr)
-{
-	struct isp_csi2_ctx_cfg *selected_ctx;
-	struct isp_csi2_ctx_cfg_update *selected_ctx_u;
-
-	isp_csi2_ctx_validate(&ctxnum);
 
-	ping_addr &= ~(0x1F);
-
-	selected_ctx = &isp_csi2->current_cfg.contexts[ctxnum];
-	selected_ctx_u = &isp_csi2->current_cfg_update.contexts[ctxnum];
-
-	if (selected_ctx->ping_addr != ping_addr) {
-		selected_ctx->ping_addr = ping_addr;
-		selected_ctx_u->ping_addr = true;
+	if (is_usr_def_mapping(ctx->format_id)) {
+		reg &= ~ISPCSI2_CTX_CTRL2_USER_DEF_MAP_MASK;
+		reg |= 2 << ISPCSI2_CTX_CTRL2_USER_DEF_MAP_SHIFT;
 	}
-	return 0;
-}
 
-/**
- * isp_csi2_ctx_config_pong_addr - Sets Pong address for CSI2 Rx. buffer saving
- * @ctxnum: Context number, valid between 0 and 7 values.
- * @pong_addr: 32 bit ISP MMU mapped address.
- *
- * Always returns 0.
- **/
-int isp_csi2_ctx_config_pong_addr(struct isp_csi2_device *isp_csi2,
-				  u8 ctxnum, u32 pong_addr)
-{
-	struct isp_csi2_ctx_cfg *selected_ctx;
-	struct isp_csi2_ctx_cfg_update *selected_ctx_u;
+	isp_reg_writel(isp, reg, csi2->regs1, ISPCSI2_CTX_CTRL2(ctx->ctxnum));
 
-	isp_csi2_ctx_validate(&ctxnum);
-
-	pong_addr &= ~(0x1F);
-
-	selected_ctx = &isp_csi2->current_cfg.contexts[ctxnum];
-	selected_ctx_u = &isp_csi2->current_cfg_update.contexts[ctxnum];
-
-	if (selected_ctx->pong_addr != pong_addr) {
-		selected_ctx->pong_addr = pong_addr;
-		selected_ctx_u->pong_addr = true;
-	}
-	return 0;
-}
+	/* Set up CSI2_CTx_CTRL3 */
+	reg = isp_reg_readl(isp, csi2->regs1, ISPCSI2_CTX_CTRL3(ctx->ctxnum));
+	reg &= ~(ISPCSI2_CTX_CTRL3_ALPHA_MASK);
+	reg |= (ctx->alpha << ISPCSI2_CTX_CTRL3_ALPHA_SHIFT);
 
-/**
- * isp_csi2_ctx_config_eof_enabled - Enables EOF signal assertion
- * @ctxnum: Context number, valid between 0 and 7 values.
- * @eof_enabled: Boolean to enable/disable EOF signal assertion on received
- *               packets.
- *
- * Always returns 0.
- **/
-int isp_csi2_ctx_config_eof_enabled(struct isp_csi2_device *isp_csi2,
-				    u8 ctxnum, bool eof_enabled)
-{
-	struct isp_csi2_ctx_cfg *selected_ctx;
-	struct isp_csi2_ctx_cfg_update *selected_ctx_u;
+	isp_reg_writel(isp, reg, csi2->regs1, ISPCSI2_CTX_CTRL3(ctx->ctxnum));
 
-	isp_csi2_ctx_validate(&ctxnum);
+	/* Set up CSI2_CTx_DAT_OFST */
+	reg = isp_reg_readl(isp, csi2->regs1,
+			    ISPCSI2_CTX_DAT_OFST(ctx->ctxnum));
+	reg &= ~ISPCSI2_CTX_DAT_OFST_OFST_MASK;
+	reg |= ctx->data_offset << ISPCSI2_CTX_DAT_OFST_OFST_SHIFT;
+	isp_reg_writel(isp, reg, csi2->regs1,
+		       ISPCSI2_CTX_DAT_OFST(ctx->ctxnum));
 
-	selected_ctx = &isp_csi2->current_cfg.contexts[ctxnum];
-	selected_ctx_u = &isp_csi2->current_cfg_update.contexts[ctxnum];
+	isp_reg_writel(isp, ctx->ping_addr,
+		       csi2->regs1, ISPCSI2_CTX_DAT_PING_ADDR(ctx->ctxnum));
 
-	if (selected_ctx->eof_enabled != eof_enabled) {
-		selected_ctx->eof_enabled = eof_enabled;
-		selected_ctx_u->eof_enabled = true;
-		isp_csi2->update_ctx_ctrl1[ctxnum] = true;
-	}
-	return 0;
+	isp_reg_writel(isp, ctx->pong_addr,
+		       csi2->regs1, ISPCSI2_CTX_DAT_PONG_ADDR(ctx->ctxnum));
 }
 
-/**
- * isp_csi2_ctx_config_eol_enabled - Enables EOL signal assertion
- * @ctxnum: Context number, valid between 0 and 7 values.
- * @eol_enabled: Boolean to enable/disable EOL signal assertion on received
- *               packets.
- *
- * Always returns 0.
- **/
-int isp_csi2_ctx_config_eol_enabled(struct isp_csi2_device *isp_csi2,
-				    u8 ctxnum, bool eol_enabled)
-{
-	struct isp_csi2_ctx_cfg *selected_ctx;
-	struct isp_csi2_ctx_cfg_update *selected_ctx_u;
-
-	isp_csi2_ctx_validate(&ctxnum);
-
-	selected_ctx = &isp_csi2->current_cfg.contexts[ctxnum];
-	selected_ctx_u = &isp_csi2->current_cfg_update.contexts[ctxnum];
-
-	if (selected_ctx->eol_enabled != eol_enabled) {
-		selected_ctx->eol_enabled = eol_enabled;
-		selected_ctx_u->eol_enabled = true;
-		isp_csi2->update_ctx_ctrl1[ctxnum] = true;
-	}
-	return 0;
-}
-
-/**
- * isp_csi2_ctx_config_checksum_enabled - Enables Checksum check in rcvd packets
- * @ctxnum: Context number, valid between 0 and 7 values.
- * @checksum_enabled: Boolean to enable/disable Checksum check on received
- *                    packets
- *
- * Always returns 0.
- **/
-int isp_csi2_ctx_config_checksum_enabled(struct isp_csi2_device *isp_csi2,
-					 u8 ctxnum, bool checksum_enabled)
-{
-	struct isp_csi2_ctx_cfg *selected_ctx;
-	struct isp_csi2_ctx_cfg_update *selected_ctx_u;
-
-	isp_csi2_ctx_validate(&ctxnum);
-
-	selected_ctx = &isp_csi2->current_cfg.contexts[ctxnum];
-	selected_ctx_u = &isp_csi2->current_cfg_update.contexts[ctxnum];
-
-	if (selected_ctx->checksum_enabled != checksum_enabled) {
-		selected_ctx->checksum_enabled = checksum_enabled;
-		selected_ctx_u->checksum_enabled = true;
-		isp_csi2->update_ctx_ctrl1[ctxnum] = true;
-	}
-	return 0;
-}
-
-/**
- * isp_csi2_ctx_config_enabled - Enables specified CSI2 context
- * @ctxnum: Context number, valid between 0 and 7 values.
- * @enabled: Boolean to enable/disable specified context.
- *
- * Always returns 0.
- **/
-int isp_csi2_ctx_config_enabled(struct isp_csi2_device *isp_csi2,
-				u8 ctxnum, bool enabled)
-{
-	struct isp_csi2_ctx_cfg *selected_ctx;
-	struct isp_csi2_ctx_cfg_update *selected_ctx_u;
-
-	isp_csi2_ctx_validate(&ctxnum);
-
-	selected_ctx = &isp_csi2->current_cfg.contexts[ctxnum];
-	selected_ctx_u = &isp_csi2->current_cfg_update.contexts[ctxnum];
-
-	if (selected_ctx->enabled != enabled) {
-		selected_ctx->enabled = enabled;
-		selected_ctx_u->enabled = true;
-		isp_csi2->update_ctx_ctrl1[ctxnum] = true;
-	}
-	return 0;
-}
-
-/**
- * isp_csi2_ctx_update - Applies CSI2 context configuration.
- * @ctxnum: Context number, valid between 0 and 7 values.
- * @force_update: Flag to force rewrite of registers, even if they haven't been
- *                updated with the isp_csi2_ctx_config_*() functions.
- *
- * It only saves settings when they were previously updated using the
- * isp_csi2_ctx_config_*() functions, unless the force_update flag is
- * set to true.
- * Always returns 0.
- **/
-int isp_csi2_ctx_update(struct isp_csi2_device *isp_csi2,
-			u8 ctxnum, bool force_update)
-{
-	struct isp_csi2_ctx_cfg *selected_ctx;
-	struct isp_csi2_ctx_cfg_update *selected_ctx_u;
-	u32 reg;
-
-	isp_csi2_ctx_validate(&ctxnum);
-
-	selected_ctx = &isp_csi2->current_cfg.contexts[ctxnum];
-	selected_ctx_u = &isp_csi2->current_cfg_update.contexts[ctxnum];
-
-	if (isp_csi2->update_ctx_ctrl1[ctxnum] || force_update) {
-		reg = isp_reg_readl(isp_csi2->dev, OMAP3_ISP_IOMEM_CSI2A,
-				    ISPCSI2_CTX_CTRL1(ctxnum));
-		if (selected_ctx_u->frame_count || force_update) {
-			reg &= ~(ISPCSI2_CTX_CTRL1_COUNT_MASK);
-			reg |= selected_ctx->frame_count <<
-				ISPCSI2_CTX_CTRL1_COUNT_SHIFT;
-			selected_ctx_u->frame_count = false;
-		}
-		if (selected_ctx_u->eof_enabled || force_update) {
-			reg &= ~(ISPCSI2_CTX_CTRL1_EOF_EN_MASK);
-			if (selected_ctx->eof_enabled)
-				reg |= ISPCSI2_CTX_CTRL1_EOF_EN_ENABLE;
-			else
-				reg |= ISPCSI2_CTX_CTRL1_EOF_EN_DISABLE;
-			selected_ctx_u->eof_enabled = false;
-		}
-		if (selected_ctx_u->eol_enabled || force_update) {
-			reg &= ~(ISPCSI2_CTX_CTRL1_EOL_EN_MASK);
-			if (selected_ctx->eol_enabled)
-				reg |= ISPCSI2_CTX_CTRL1_EOL_EN_ENABLE;
-			else
-				reg |= ISPCSI2_CTX_CTRL1_EOL_EN_DISABLE;
-			selected_ctx_u->eol_enabled = false;
-		}
-		if (selected_ctx_u->checksum_enabled || force_update) {
-			reg &= ~(ISPCSI2_CTX_CTRL1_CS_EN_MASK);
-			if (selected_ctx->checksum_enabled)
-				reg |= ISPCSI2_CTX_CTRL1_CS_EN_ENABLE;
-			else
-				reg |= ISPCSI2_CTX_CTRL1_CS_EN_DISABLE;
-			selected_ctx_u->checksum_enabled = false;
-		}
-		if (selected_ctx_u->enabled || force_update) {
-			reg &= ~(ISPCSI2_CTX_CTRL1_CTX_EN_MASK);
-			if (selected_ctx->enabled)
-				reg |= ISPCSI2_CTX_CTRL1_CTX_EN_ENABLE;
-			else
-				reg |= ISPCSI2_CTX_CTRL1_CTX_EN_DISABLE;
-			selected_ctx_u->enabled = false;
-		}
-		isp_reg_writel(isp_csi2->dev, reg, OMAP3_ISP_IOMEM_CSI2A,
-			       ISPCSI2_CTX_CTRL1(ctxnum));
-		isp_csi2->update_ctx_ctrl1[ctxnum] = false;
-	}
-
-	if (isp_csi2->update_ctx_ctrl2[ctxnum] || force_update) {
-		reg = isp_reg_readl(isp_csi2->dev, OMAP3_ISP_IOMEM_CSI2A,
-				    ISPCSI2_CTX_CTRL2(ctxnum));
-		if (selected_ctx_u->virtual_id || force_update) {
-			reg &= ~(ISPCSI2_CTX_CTRL2_VIRTUAL_ID_MASK);
-			reg |= selected_ctx->virtual_id <<
-				ISPCSI2_CTX_CTRL2_VIRTUAL_ID_SHIFT;
-			selected_ctx_u->virtual_id = false;
-		}
-
-		if (selected_ctx_u->format || force_update) {
-			struct v4l2_pix_format *pix;
-			u16 new_format = 0;
-
-			reg &= ~(ISPCSI2_CTX_CTRL2_FORMAT_MASK);
-			pix = &selected_ctx->format;
-			switch (pix->pixelformat) {
-			case V4L2_PIX_FMT_RGB565:
-			case V4L2_PIX_FMT_RGB565X:
-				new_format = 0x22;
-				break;
-			case V4L2_PIX_FMT_YUYV:
-			case V4L2_PIX_FMT_UYVY:
-				if (isp_csi2->uses_videoport)
-					new_format = 0x9E;
-				else
-					new_format = 0x1E;
-				break;
-			case V4L2_PIX_FMT_RGB555:
-			case V4L2_PIX_FMT_RGB555X:
-				new_format = 0xA1;
-				break;
-			case V4L2_PIX_FMT_SGRBG10:
-			case V4L2_PIX_FMT_SRGGB10:
-			case V4L2_PIX_FMT_SBGGR10:
-			case V4L2_PIX_FMT_SGBRG10:
-				if (isp_csi2->uses_videoport)
-					new_format = 0x12F;
-				else
-					new_format = 0xAB;
-				break;
-			}
-			reg |= (new_format << ISPCSI2_CTX_CTRL2_FORMAT_SHIFT);
-			selected_ctx_u->format = false;
-		}
-		isp_reg_writel(isp_csi2->dev, reg, OMAP3_ISP_IOMEM_CSI2A,
-			       ISPCSI2_CTX_CTRL2(ctxnum));
-		isp_csi2->update_ctx_ctrl2[ctxnum] = false;
-	}
-
-	if (isp_csi2->update_ctx_ctrl3[ctxnum] || force_update) {
-		reg = isp_reg_readl(isp_csi2->dev, OMAP3_ISP_IOMEM_CSI2A,
-				    ISPCSI2_CTX_CTRL3(ctxnum));
-		if (selected_ctx_u->alpha || force_update) {
-			reg &= ~(ISPCSI2_CTX_CTRL3_ALPHA_MASK);
-			reg |= (selected_ctx->alpha <<
-				ISPCSI2_CTX_CTRL3_ALPHA_SHIFT);
-			selected_ctx_u->alpha = false;
-		}
-		isp_reg_writel(isp_csi2->dev, reg, OMAP3_ISP_IOMEM_CSI2A,
-			       ISPCSI2_CTX_CTRL3(ctxnum));
-		isp_csi2->update_ctx_ctrl3[ctxnum] = false;
-	}
-
-	if (selected_ctx_u->data_offset) {
-		reg = isp_reg_readl(isp_csi2->dev, OMAP3_ISP_IOMEM_CSI2A,
-				    ISPCSI2_CTX_DAT_OFST(ctxnum));
-		reg &= ~ISPCSI2_CTX_DAT_OFST_OFST_MASK;
-		reg |= selected_ctx->data_offset <<
-			ISPCSI2_CTX_DAT_OFST_OFST_SHIFT;
-		isp_reg_writel(isp_csi2->dev, reg, OMAP3_ISP_IOMEM_CSI2A,
-			       ISPCSI2_CTX_DAT_OFST(ctxnum));
-		selected_ctx_u->data_offset = false;
-	}
-
-	if (selected_ctx_u->ping_addr) {
-		reg = selected_ctx->ping_addr;
-		isp_reg_writel(isp_csi2->dev, reg, OMAP3_ISP_IOMEM_CSI2A,
-			       ISPCSI2_CTX_DAT_PING_ADDR(ctxnum));
-		selected_ctx_u->ping_addr = false;
-	}
-
-	if (selected_ctx_u->pong_addr) {
-		reg = selected_ctx->pong_addr;
-		isp_reg_writel(isp_csi2->dev, reg, OMAP3_ISP_IOMEM_CSI2A,
-			       ISPCSI2_CTX_DAT_PONG_ADDR(ctxnum));
-		selected_ctx_u->pong_addr = false;
-	}
-	return 0;
-}
-
-/**
- * isp_csi2_ctx_get - Gets specific CSI2 Context configuration
- * @ctxnum: Context number, valid between 0 and 7 values.
- *
- * Always returns 0.
- **/
-int isp_csi2_ctx_get(struct isp_csi2_device *isp_csi2, u8 ctxnum)
+/*
+ * csi2_timing_config - CSI2 timing configuration.
+ * @timing: csi2_timing_cfg structure
+ */
+static void csi2_timing_config(struct isp_device *isp,
+			       struct isp_csi2_device *csi2,
+			       struct isp_csi2_timing_cfg *timing)
 {
-	struct isp_csi2_ctx_cfg *selected_ctx;
-	struct isp_csi2_ctx_cfg_update *selected_ctx_u;
 	u32 reg;
 
-	isp_csi2_ctx_validate(&ctxnum);
-
-	selected_ctx = &isp_csi2->current_cfg.contexts[ctxnum];
-	selected_ctx_u = &isp_csi2->current_cfg_update.contexts[ctxnum];
-
-	reg = isp_reg_readl(isp_csi2->dev, OMAP3_ISP_IOMEM_CSI2A,
-			    ISPCSI2_CTX_CTRL1(ctxnum));
-	selected_ctx->frame_count = (reg & ISPCSI2_CTX_CTRL1_COUNT_MASK) >>
-		ISPCSI2_CTX_CTRL1_COUNT_SHIFT;
-	selected_ctx_u->frame_count = false;
-
-	if ((reg & ISPCSI2_CTX_CTRL1_EOF_EN_MASK) ==
-	    ISPCSI2_CTX_CTRL1_EOF_EN_ENABLE)
-		selected_ctx->eof_enabled = true;
-	else
-		selected_ctx->eof_enabled = false;
-	selected_ctx_u->eof_enabled = false;
+	reg = isp_reg_readl(isp, csi2->regs1, ISPCSI2_TIMING);
 
-	if ((reg & ISPCSI2_CTX_CTRL1_EOL_EN_MASK) ==
-	    ISPCSI2_CTX_CTRL1_EOL_EN_ENABLE)
-		selected_ctx->eol_enabled = true;
+	if (timing->force_rx_mode)
+		reg |= ISPCSI2_TIMING_FORCE_RX_MODE_IO(timing->ionum);
 	else
-		selected_ctx->eol_enabled = false;
-	selected_ctx_u->eol_enabled = false;
+		reg &= ~ISPCSI2_TIMING_FORCE_RX_MODE_IO(timing->ionum);
 
-	if ((reg & ISPCSI2_CTX_CTRL1_CS_EN_MASK) ==
-	    ISPCSI2_CTX_CTRL1_CS_EN_ENABLE)
-		selected_ctx->checksum_enabled = true;
+	if (timing->stop_state_16x)
+		reg |= ISPCSI2_TIMING_STOP_STATE_X16_IO(timing->ionum);
 	else
-		selected_ctx->checksum_enabled = false;
-	selected_ctx_u->checksum_enabled = false;
+		reg &= ~ISPCSI2_TIMING_STOP_STATE_X16_IO(timing->ionum);
 
-	if ((reg & ISPCSI2_CTX_CTRL1_CTX_EN_MASK) ==
-	    ISPCSI2_CTX_CTRL1_CTX_EN_ENABLE)
-		selected_ctx->enabled = true;
+	if (timing->stop_state_4x)
+		reg |= ISPCSI2_TIMING_STOP_STATE_X4_IO(timing->ionum);
 	else
-		selected_ctx->enabled = false;
-	selected_ctx_u->enabled = false;
-	isp_csi2->update_ctx_ctrl1[ctxnum] = false;
-
-	reg = isp_reg_readl(isp_csi2->dev, OMAP3_ISP_IOMEM_CSI2A,
-			    ISPCSI2_CTX_CTRL2(ctxnum));
+		reg &= ~ISPCSI2_TIMING_STOP_STATE_X4_IO(timing->ionum);
 
-	selected_ctx->virtual_id = (reg & ISPCSI2_CTX_CTRL2_VIRTUAL_ID_MASK) >>
-		ISPCSI2_CTX_CTRL2_VIRTUAL_ID_SHIFT;
-	selected_ctx_u->virtual_id = false;
+	reg &= ~ISPCSI2_TIMING_STOP_STATE_COUNTER_IO_MASK(timing->ionum);
+	reg |= timing->stop_state_counter <<
+	       ISPCSI2_TIMING_STOP_STATE_COUNTER_IO_SHIFT(timing->ionum);
 
-	switch ((reg & ISPCSI2_CTX_CTRL2_FORMAT_MASK) >>
-		ISPCSI2_CTX_CTRL2_FORMAT_SHIFT) {
-	case 0x22:
-		selected_ctx->format.pixelformat = V4L2_PIX_FMT_RGB565;
-		break;
-	case 0x9E:
-	case 0x1E:
-		selected_ctx->format.pixelformat = V4L2_PIX_FMT_YUYV;
-		break;
-	case 0xA1:
-		selected_ctx->format.pixelformat = V4L2_PIX_FMT_RGB555;
-		break;
-	case 0xAB:
-	case 0x12F:
-		selected_ctx->format.pixelformat = V4L2_PIX_FMT_SGRBG10;
-		break;
-	}
-	selected_ctx_u->format = false;
-	isp_csi2->update_ctx_ctrl2[ctxnum] = false;
-
-	selected_ctx->alpha = (isp_reg_readl(isp_csi2->dev,
-					     OMAP3_ISP_IOMEM_CSI2A,
-					     ISPCSI2_CTX_CTRL3(ctxnum)) &
-			       ISPCSI2_CTX_CTRL3_ALPHA_MASK) >>
-		ISPCSI2_CTX_CTRL3_ALPHA_SHIFT;
-	selected_ctx_u->alpha = false;
-	isp_csi2->update_ctx_ctrl3[ctxnum] = false;
-
-	selected_ctx->data_offset = (isp_reg_readl(isp_csi2->dev,
-						   OMAP3_ISP_IOMEM_CSI2A,
-						   ISPCSI2_CTX_DAT_OFST(ctxnum)) &
-				     ISPCSI2_CTX_DAT_OFST_OFST_MASK) >>
-		ISPCSI2_CTX_DAT_OFST_OFST_SHIFT;
-	selected_ctx_u->data_offset = false;
-
-	selected_ctx->ping_addr = isp_reg_readl(isp_csi2->dev,
-						OMAP3_ISP_IOMEM_CSI2A,
-						ISPCSI2_CTX_DAT_PING_ADDR(ctxnum));
-	selected_ctx_u->ping_addr = false;
-
-	selected_ctx->pong_addr = isp_reg_readl(isp_csi2->dev,
-						OMAP3_ISP_IOMEM_CSI2A,
-						ISPCSI2_CTX_DAT_PONG_ADDR(ctxnum));
-	selected_ctx_u->pong_addr = false;
-	return 0;
+	isp_reg_writel(isp, reg, csi2->regs1, ISPCSI2_TIMING);
 }
 
-/**
- * isp_csi2_ctx_update_all - Applies all CSI2 context configuration.
- * @force_update: Flag to force rewrite of registers, even if they haven't been
- *                updated with the isp_csi2_ctx_config_*() functions.
- *
- * It only saves settings when they were previously updated using the
- * isp_csi2_ctx_config_*() functions, unless the force_update flag is
- * set to true.
- * Always returns 0.
- **/
-int isp_csi2_ctx_update_all(struct isp_csi2_device *isp_csi2, bool force_update)
-{
-	u8 ctxnum;
-
-	for (ctxnum = 0; ctxnum < 8; ctxnum++)
-		isp_csi2_ctx_update(isp_csi2, ctxnum, force_update);
-
-	return 0;
-}
-
-/**
- * isp_csi2_ctx_get_all - Gets all CSI2 Context configurations
- *
- * Always returns 0.
- **/
-int isp_csi2_ctx_get_all(struct isp_csi2_device *isp_csi2)
+/*
+ * csi2_irq_ctx_set - Enables CSI2 Context IRQs.
+ * @enable: Enable/disable CSI2 Context interrupts
+ */
+static void csi2_irq_ctx_set(struct isp_device *isp,
+			     struct isp_csi2_device *csi2, int enable)
 {
-	u8 ctxnum;
-
-	for (ctxnum = 0; ctxnum < 8; ctxnum++)
-		isp_csi2_ctx_get(isp_csi2, ctxnum);
+	u32 reg = ISPCSI2_CTX_IRQSTATUS_FE_IRQ;
+	int i;
 
-	return 0;
-}
+	if (csi2->use_fs_irq)
+		reg |= ISPCSI2_CTX_IRQSTATUS_FS_IRQ;
 
-int isp_csi2_phy_config(struct isp_csi2_device *isp_csi2,
-			struct isp_csi2_phy_cfg *desiredphyconfig)
-{
-	struct isp_csi2_phy_cfg *currphy = &isp_csi2->current_cfg.phy;
-	struct isp_csi2_phy_cfg_update *currphy_u =
-						&isp_csi2->current_cfg_update.phy;
-
-	if ((desiredphyconfig->tclk_term > 0x7f) ||
-				(desiredphyconfig->tclk_miss > 0x3)) {
-		printk(KERN_ERR "Invalid PHY configuration sent by the"
-								" driver\n");
-		return -EINVAL;
-	}
-
-	if (currphy->ths_term != desiredphyconfig->ths_term) {
-		currphy->ths_term = desiredphyconfig->ths_term;
-		currphy_u->ths_term = true;
-		isp_csi2->update_phy_cfg0 = true;
-	}
-	if (currphy->ths_settle != desiredphyconfig->ths_settle) {
-		currphy->ths_settle = desiredphyconfig->ths_settle;
-		currphy_u->ths_settle = true;
-		isp_csi2->update_phy_cfg0 = true;
-	}
-	if (currphy->tclk_term != desiredphyconfig->tclk_term) {
-		currphy->tclk_term = desiredphyconfig->tclk_term;
-		currphy_u->tclk_term = true;
-		isp_csi2->update_phy_cfg1 = true;
-	}
-	if (currphy->tclk_miss != desiredphyconfig->tclk_miss) {
-		currphy->tclk_miss = desiredphyconfig->tclk_miss;
-		currphy_u->tclk_miss = true;
-		isp_csi2->update_phy_cfg1 = true;
-	}
-	if (currphy->tclk_settle != desiredphyconfig->tclk_settle) {
-		currphy->tclk_settle = desiredphyconfig->tclk_settle;
-		currphy_u->tclk_settle = true;
-		isp_csi2->update_phy_cfg1 = true;
+	for (i = 0; i < 8; i++) {
+		isp_reg_writel(isp, reg, csi2->regs1,
+			       ISPCSI2_CTX_IRQSTATUS(i));
+		if (enable)
+			isp_reg_set(isp, csi2->regs1, ISPCSI2_CTX_IRQENABLE(i),
+				    reg);
+		else
+			isp_reg_clr(isp, csi2->regs1, ISPCSI2_CTX_IRQENABLE(i),
+				    reg);
 	}
-	return 0;
 }
 
-/**
- * isp_csi2_calc_phy_cfg0 - Calculates D-PHY config based on the MIPIClk speed.
- * @mipiclk: MIPI clock frequency being used with CSI2 sensor.
- * @lbound_hs_settle: Lower bound for CSI2 High Speed Settle transition.
- * @ubound_hs_settle: Upper bound for CSI2 High Speed Settle transition.
- *
- * From TRM, we have the same calculation for HS Termination signal.
- *  THS_TERM  = ceil( 12.5ns / DDRCLK period ) - 1
- * But for Settle, we use the mid value between the two passed boundaries from
- * sensor:
- *  THS_SETTLE = (Upper bound + Lower bound) / 2
- *
- * Always returns 0.
+/*
+ * csi2_irq_complexio1_set - Enables CSI2 ComplexIO IRQs.
+ * @enable: Enable/disable CSI2 ComplexIO #1 interrupts
  */
-int isp_csi2_calc_phy_cfg0(struct isp_csi2_device *isp_csi2,
-			   u32 mipiclk, u32 lbound_hs_settle,
-			   u32 ubound_hs_settle)
+static void csi2_irq_complexio1_set(struct isp_device *isp,
+				    struct isp_csi2_device *csi2, int enable)
 {
-	struct isp_csi2_phy_cfg *currphy = &isp_csi2->current_cfg.phy;
-	struct isp_csi2_phy_cfg_update *currphy_u =
-						&isp_csi2->current_cfg_update.phy;
-	u32 tmp, ddrclk = mipiclk >> 1;
-
-	/* Calculate THS_TERM */
-	tmp = ddrclk / 80000000;
-	if ((ddrclk % 80000000) > 0)
-		tmp++;
-	currphy->ths_term = tmp - 1;
-	currphy_u->ths_term = true;
-
-	/* Calculate THS_SETTLE */
-	currphy->ths_settle = (ubound_hs_settle + lbound_hs_settle) / 2;
-
-	currphy_u->ths_settle = true;
-	isp_csi2_phy_update(isp_csi2, true);
-	return 0;
-}
-EXPORT_SYMBOL(isp_csi2_calc_phy_cfg0);
-
-/**
- * isp_csi2_phy_update - Applies CSI2 D-PHY configuration.
- * @force_update: Flag to force rewrite of registers, even if they haven't been
- *                updated with the isp_csi2_phy_config_*() functions.
- *
- * It only saves settings when they were previously updated using the
- * isp_csi2_phy_config_*() functions, unless the force_update flag is
-	* set to true.
-	* Always returns 0.
-	**/
-int isp_csi2_phy_update(struct isp_csi2_device *isp_csi2, bool force_update)
-{
-	struct isp_csi2_phy_cfg *currphy = &isp_csi2->current_cfg.phy;
-	struct isp_csi2_phy_cfg_update *currphy_u =
-		&isp_csi2->current_cfg_update.phy;
 	u32 reg;
-
-	if (isp_csi2->update_phy_cfg0 || force_update) {
-		reg = isp_reg_readl(isp_csi2->dev,
-				    OMAP3_ISP_IOMEM_CSI2PHY,
-				    ISPCSI2PHY_CFG0);
-		if (currphy_u->ths_term || force_update) {
-			reg &= ~ISPCSI2PHY_CFG0_THS_TERM_MASK;
-			reg |= (currphy->ths_term <<
-				ISPCSI2PHY_CFG0_THS_TERM_SHIFT);
-			currphy_u->ths_term = false;
-		}
-		if (currphy_u->ths_settle || force_update) {
-			reg &= ~ISPCSI2PHY_CFG0_THS_SETTLE_MASK;
-			reg |= (currphy->ths_settle <<
-				ISPCSI2PHY_CFG0_THS_SETTLE_SHIFT);
-			currphy_u->ths_settle = false;
-		}
-		isp_reg_writel(isp_csi2->dev, reg,
-			       OMAP3_ISP_IOMEM_CSI2PHY, ISPCSI2PHY_CFG0);
-		isp_csi2->update_phy_cfg0 = false;
-	}
-
-	if (isp_csi2->update_phy_cfg1 || force_update) {
-		reg = isp_reg_readl(isp_csi2->dev,
-				    OMAP3_ISP_IOMEM_CSI2PHY, ISPCSI2PHY_CFG1);
-		if (currphy_u->tclk_term || force_update) {
-			reg &= ~ISPCSI2PHY_CFG1_TCLK_TERM_MASK;
-			reg |= (currphy->tclk_term <<
-				ISPCSI2PHY_CFG1_TCLK_TERM_SHIFT);
-			currphy_u->tclk_term = false;
-		}
-		if (currphy_u->tclk_miss || force_update) {
-			reg &= ~ISPCSI2PHY_CFG1_TCLK_MISS_MASK;
-			reg |= (currphy->tclk_miss <<
-				ISPCSI2PHY_CFG1_TCLK_MISS_SHIFT);
-			currphy_u->tclk_miss = false;
-		}
-		if (currphy_u->tclk_settle || force_update) {
-			reg &= ~ISPCSI2PHY_CFG1_TCLK_SETTLE_MASK;
-			reg |= (currphy->tclk_settle <<
-				ISPCSI2PHY_CFG1_TCLK_SETTLE_SHIFT);
-			currphy_u->tclk_settle = false;
-		}
-		isp_reg_writel(isp_csi2->dev, reg,
-			       OMAP3_ISP_IOMEM_CSI2PHY, ISPCSI2PHY_CFG1);
-		isp_csi2->update_phy_cfg1 = false;
-	}
-	return 0;
+	reg = ISPCSI2_PHY_IRQENABLE_STATEALLULPMEXIT |
+		ISPCSI2_PHY_IRQENABLE_STATEALLULPMENTER |
+		ISPCSI2_PHY_IRQENABLE_STATEULPM5 |
+		ISPCSI2_PHY_IRQENABLE_ERRCONTROL5 |
+		ISPCSI2_PHY_IRQENABLE_ERRESC5 |
+		ISPCSI2_PHY_IRQENABLE_ERRSOTSYNCHS5 |
+		ISPCSI2_PHY_IRQENABLE_ERRSOTHS5 |
+		ISPCSI2_PHY_IRQENABLE_STATEULPM4 |
+		ISPCSI2_PHY_IRQENABLE_ERRCONTROL4 |
+		ISPCSI2_PHY_IRQENABLE_ERRESC4 |
+		ISPCSI2_PHY_IRQENABLE_ERRSOTSYNCHS4 |
+		ISPCSI2_PHY_IRQENABLE_ERRSOTHS4 |
+		ISPCSI2_PHY_IRQENABLE_STATEULPM3 |
+		ISPCSI2_PHY_IRQENABLE_ERRCONTROL3 |
+		ISPCSI2_PHY_IRQENABLE_ERRESC3 |
+		ISPCSI2_PHY_IRQENABLE_ERRSOTSYNCHS3 |
+		ISPCSI2_PHY_IRQENABLE_ERRSOTHS3 |
+		ISPCSI2_PHY_IRQENABLE_STATEULPM2 |
+		ISPCSI2_PHY_IRQENABLE_ERRCONTROL2 |
+		ISPCSI2_PHY_IRQENABLE_ERRESC2 |
+		ISPCSI2_PHY_IRQENABLE_ERRSOTSYNCHS2 |
+		ISPCSI2_PHY_IRQENABLE_ERRSOTHS2 |
+		ISPCSI2_PHY_IRQENABLE_STATEULPM1 |
+		ISPCSI2_PHY_IRQENABLE_ERRCONTROL1 |
+		ISPCSI2_PHY_IRQENABLE_ERRESC1 |
+		ISPCSI2_PHY_IRQENABLE_ERRSOTSYNCHS1 |
+		ISPCSI2_PHY_IRQENABLE_ERRSOTHS1;
+	isp_reg_writel(isp, reg, csi2->regs1, ISPCSI2_PHY_IRQSTATUS);
+	if (enable)
+		reg |= isp_reg_readl(isp, csi2->regs1, ISPCSI2_PHY_IRQENABLE);
+	else
+		reg = 0;
+	isp_reg_writel(isp, reg, csi2->regs1, ISPCSI2_PHY_IRQENABLE);
 }
 
-/**
- * isp_csi2_phy_get - Gets CSI2 D-PHY configuration
- *
- * Gets settings from HW registers and fills in the internal driver memory
- * Always returns 0.
- **/
-int isp_csi2_phy_get(struct isp_csi2_device *isp_csi2)
+/*
+ * csi2_irq_status_set - Enables CSI2 Status IRQs.
+ * @enable: Enable/disable CSI2 Status interrupts
+ */
+static void csi2_irq_status_set(struct isp_device *isp,
+				struct isp_csi2_device *csi2, int enable)
 {
-	struct isp_csi2_phy_cfg *currphy = &isp_csi2->current_cfg.phy;
-	struct isp_csi2_phy_cfg_update *currphy_u =
-		&isp_csi2->current_cfg_update.phy;
 	u32 reg;
+	reg = ISPCSI2_IRQSTATUS_OCP_ERR_IRQ |
+		ISPCSI2_IRQSTATUS_SHORT_PACKET_IRQ |
+		ISPCSI2_IRQSTATUS_ECC_CORRECTION_IRQ |
+		ISPCSI2_IRQSTATUS_ECC_NO_CORRECTION_IRQ |
+		ISPCSI2_IRQSTATUS_COMPLEXIO2_ERR_IRQ |
+		ISPCSI2_IRQSTATUS_COMPLEXIO1_ERR_IRQ |
+		ISPCSI2_IRQSTATUS_FIFO_OVF_IRQ |
+		ISPCSI2_IRQSTATUS_CONTEXT(0);
+	isp_reg_writel(isp, reg, csi2->regs1, ISPCSI2_IRQSTATUS);
+	if (enable)
+		reg |= isp_reg_readl(isp, csi2->regs1, ISPCSI2_IRQENABLE);
+	else
+		reg = 0;
 
-	reg = isp_reg_readl(isp_csi2->dev, OMAP3_ISP_IOMEM_CSI2PHY,
-			    ISPCSI2PHY_CFG0);
-	currphy->ths_term = (reg & ISPCSI2PHY_CFG0_THS_TERM_MASK) >>
-		ISPCSI2PHY_CFG0_THS_TERM_SHIFT;
-	currphy_u->ths_term = false;
-
-	currphy->ths_settle = (reg & ISPCSI2PHY_CFG0_THS_SETTLE_MASK) >>
-		ISPCSI2PHY_CFG0_THS_SETTLE_SHIFT;
-	currphy_u->ths_settle = false;
-	isp_csi2->update_phy_cfg0 = false;
-
-	reg = isp_reg_readl(isp_csi2->dev, OMAP3_ISP_IOMEM_CSI2PHY,
-			    ISPCSI2PHY_CFG1);
-
-	currphy->tclk_term = (reg & ISPCSI2PHY_CFG1_TCLK_TERM_MASK) >>
-		ISPCSI2PHY_CFG1_TCLK_TERM_SHIFT;
-	currphy_u->tclk_term = false;
-
-	currphy->tclk_miss = (reg & ISPCSI2PHY_CFG1_TCLK_MISS_MASK) >>
-		ISPCSI2PHY_CFG1_TCLK_MISS_SHIFT;
-	currphy_u->tclk_miss = false;
-
-	currphy->tclk_settle = (reg & ISPCSI2PHY_CFG1_TCLK_SETTLE_MASK) >>
-		ISPCSI2PHY_CFG1_TCLK_SETTLE_SHIFT;
-	currphy_u->tclk_settle = false;
-
-	isp_csi2->update_phy_cfg1 = false;
-	return 0;
-}
-
-/**
- * isp_csi2_timings_config_forcerxmode - Sets Force Rx mode on stop state count
- * @force_rx_mode: Boolean to enable/disable forcing Rx mode in CSI2 receiver
- *
- * Returns 0 if successful, or -EINVAL if wrong ComplexIO number is selected.
- **/
-int isp_csi2_timings_config_forcerxmode(struct isp_csi2_device *isp_csi2,
-					u8 io, bool force_rx_mode)
-{
-	struct isp_csi2_timings_cfg *currtimings;
-	struct isp_csi2_timings_cfg_update *currtimings_u;
-
-	if (io < 1 || io > 2) {
-		printk(KERN_ERR "CSI2 - Timings config: Invalid IO number\n");
-		return -EINVAL;
-	}
-
-	currtimings = &isp_csi2->current_cfg.timings[io - 1];
-	currtimings_u = &isp_csi2->current_cfg_update.timings[io - 1];
-	if (currtimings->force_rx_mode != force_rx_mode) {
-		currtimings->force_rx_mode = force_rx_mode;
-		currtimings_u->force_rx_mode = true;
-		isp_csi2->update_timing = true;
-	}
-	return 0;
+	isp_reg_writel(isp, reg, csi2->regs1, ISPCSI2_IRQENABLE);
 }
 
-/**
- * isp_csi2_timings_config_stopstate_16x - Sets 16x factor for L3 cycles
- * @stop_state_16x: Boolean to use or not use the 16x multiplier for stop count
+/*
+ * omap3isp_csi2_reset - Resets the CSI2 module.
+ *
+ * Must be called with the phy lock held.
  *
- * Returns 0 if successful, or -EINVAL if wrong ComplexIO number is selected.
- **/
-int isp_csi2_timings_config_stopstate_16x(struct isp_csi2_device *isp_csi2,
-					  u8 io, bool stop_state_16x)
+ * Returns 0 if successful, or -EBUSY if power command didn't respond.
+ */
+int omap3isp_csi2_reset(struct isp_csi2_device *csi2)
 {
-	struct isp_csi2_timings_cfg *currtimings;
-	struct isp_csi2_timings_cfg_update *currtimings_u;
+	struct isp_device *isp = csi2->isp;
+	u8 soft_reset_retries = 0;
+	u32 reg;
+	int i;
 
-	if (io < 1 || io > 2) {
-		printk(KERN_ERR "CSI2 - Timings config: Invalid IO number\n");
-		return -EINVAL;
-	}
+	if (!csi2->available)
+		return -ENODEV;
 
-	currtimings = &isp_csi2->current_cfg.timings[io - 1];
-	currtimings_u = &isp_csi2->current_cfg_update.timings[io - 1];
-	if (currtimings->stop_state_16x != stop_state_16x) {
-		currtimings->stop_state_16x = stop_state_16x;
-		currtimings_u->stop_state_16x = true;
-		isp_csi2->update_timing = true;
-	}
-	return 0;
-}
+	if (csi2->phy->phy_in_use)
+		return -EBUSY;
 
-/**
- * isp_csi2_timings_config_stopstate_4x - Sets 4x factor for L3 cycles
- * @stop_state_4x: Boolean to use or not use the 4x multiplier for stop count
- *
- * Returns 0 if successful, or -EINVAL if wrong ComplexIO number is selected.
- **/
-int isp_csi2_timings_config_stopstate_4x(struct isp_csi2_device *isp_csi2,
-					 u8 io, bool stop_state_4x)
-{
-	struct isp_csi2_timings_cfg *currtimings;
-	struct isp_csi2_timings_cfg_update *currtimings_u;
+	isp_reg_set(isp, csi2->regs1, ISPCSI2_SYSCONFIG,
+		    ISPCSI2_SYSCONFIG_SOFT_RESET);
 
-	if (io < 1 || io > 2) {
-		printk(KERN_ERR "CSI2 - Timings config: Invalid IO number\n");
-		return -EINVAL;
-	}
+	do {
+		reg = isp_reg_readl(isp, csi2->regs1, ISPCSI2_SYSSTATUS) &
+				    ISPCSI2_SYSSTATUS_RESET_DONE;
+		if (reg == ISPCSI2_SYSSTATUS_RESET_DONE)
+			break;
+		soft_reset_retries++;
+		if (soft_reset_retries < 5)
+			udelay(100);
+	} while (soft_reset_retries < 5);
 
-	currtimings = &isp_csi2->current_cfg.timings[io - 1];
-	currtimings_u = &isp_csi2->current_cfg_update.timings[io - 1];
-	if (currtimings->stop_state_4x != stop_state_4x) {
-		currtimings->stop_state_4x = stop_state_4x;
-		currtimings_u->stop_state_4x = true;
-		isp_csi2->update_timing = true;
+	if (soft_reset_retries == 5) {
+		printk(KERN_ERR "CSI2: Soft reset try count exceeded!\n");
+		return -EBUSY;
 	}
-	return 0;
-}
 
-/**
- * isp_csi2_timings_config_stopstate_cnt - Sets L3 cycles
- * @stop_state_counter: Stop state counter value for L3 cycles
- *
- * Returns 0 if successful, or -EINVAL if wrong ComplexIO number is selected.
- **/
-int isp_csi2_timings_config_stopstate_cnt(struct isp_csi2_device *isp_csi2,
-					  u8 io, u16 stop_state_counter)
-{
-	struct isp_csi2_timings_cfg *currtimings;
-	struct isp_csi2_timings_cfg_update *currtimings_u;
+	if (isp->revision == ISP_REVISION_15_0)
+		isp_reg_set(isp, csi2->regs1, ISPCSI2_PHY_CFG,
+			    ISPCSI2_PHY_CFG_RESET_CTRL);
 
-	if (io < 1 || io > 2) {
-		printk(KERN_ERR "CSI2 - Timings config: Invalid IO number\n");
-		return -EINVAL;
-	}
+	i = 100;
+	do {
+		reg = isp_reg_readl(isp, csi2->phy->phy_regs, ISPCSIPHY_REG1)
+		    & ISPCSIPHY_REG1_RESET_DONE_CTRLCLK;
+		if (reg == ISPCSIPHY_REG1_RESET_DONE_CTRLCLK)
+			break;
+		udelay(100);
+	} while (--i > 0);
 
-	currtimings = &isp_csi2->current_cfg.timings[io - 1];
-	currtimings_u = &isp_csi2->current_cfg_update.timings[io - 1];
-	if (currtimings->stop_state_counter != stop_state_counter) {
-		currtimings->stop_state_counter = (stop_state_counter & 0x1FFF);
-		currtimings_u->stop_state_counter = true;
-		isp_csi2->update_timing = true;
+	if (i == 0) {
+		printk(KERN_ERR
+		       "CSI2: Reset for CSI2_96M_FCLK domain Failed!\n");
+		return -EBUSY;
 	}
-	return 0;
-}
-
-/**
- * isp_csi2_timings_update - Applies specified CSI2 timing configuration.
- * @io: IO number (1 or 2) which specifies which ComplexIO are we updating
- * @force_update: Flag to force rewrite of registers, even if they haven't been
- *                updated with the isp_csi2_timings_config_*() functions.
- *
- * It only saves settings when they were previously updated using the
- * isp_csi2_timings_config_*() functions, unless the force_update flag is
- * set to true.
- * Returns 0 if successful, or -EINVAL if invalid IO number is passed.
- **/
-int isp_csi2_timings_update(struct isp_csi2_device *isp_csi2,
-			    u8 io, bool force_update)
-{
-	struct isp_csi2_timings_cfg *currtimings;
-	struct isp_csi2_timings_cfg_update *currtimings_u;
-	u32 reg;
 
-	if (io < 1 || io > 2) {
-		printk(KERN_ERR "CSI2 - Timings config: Invalid IO number\n");
-		return -EINVAL;
-	}
+	if (isp->autoidle)
+		isp_reg_clr_set(isp, csi2->regs1, ISPCSI2_SYSCONFIG,
+				ISPCSI2_SYSCONFIG_MSTANDBY_MODE_MASK |
+				ISPCSI2_SYSCONFIG_AUTO_IDLE,
+				ISPCSI2_SYSCONFIG_MSTANDBY_MODE_SMART |
+				((isp->revision == ISP_REVISION_15_0) ?
+				 ISPCSI2_SYSCONFIG_AUTO_IDLE : 0));
+	else
+		isp_reg_clr_set(isp, csi2->regs1, ISPCSI2_SYSCONFIG,
+				ISPCSI2_SYSCONFIG_MSTANDBY_MODE_MASK |
+				ISPCSI2_SYSCONFIG_AUTO_IDLE,
+				ISPCSI2_SYSCONFIG_MSTANDBY_MODE_NO);
 
-	currtimings = &isp_csi2->current_cfg.timings[io - 1];
-	currtimings_u = &isp_csi2->current_cfg_update.timings[io - 1];
-
-	if (isp_csi2->update_timing || force_update) {
-		reg = isp_reg_readl(isp_csi2->dev, OMAP3_ISP_IOMEM_CSI2A,
-				    ISPCSI2_TIMING);
-		if (currtimings_u->force_rx_mode || force_update) {
-			reg &= ~ISPCSI2_TIMING_FORCE_RX_MODE_IO_MASK(io);
-			if (currtimings->force_rx_mode)
-				reg |= ISPCSI2_TIMING_FORCE_RX_MODE_IO_ENABLE
-					(io);
-			else
-				reg |= ISPCSI2_TIMING_FORCE_RX_MODE_IO_DISABLE
-					(io);
-			currtimings_u->force_rx_mode = false;
-		}
-		if (currtimings_u->stop_state_16x || force_update) {
-			reg &= ~ISPCSI2_TIMING_STOP_STATE_X16_IO_MASK(io);
-			if (currtimings->stop_state_16x)
-				reg |= ISPCSI2_TIMING_STOP_STATE_X16_IO_ENABLE
-					(io);
-			else
-				reg |= ISPCSI2_TIMING_STOP_STATE_X16_IO_DISABLE
-					(io);
-			currtimings_u->stop_state_16x = false;
-		}
-		if (currtimings_u->stop_state_4x || force_update) {
-			reg &= ~ISPCSI2_TIMING_STOP_STATE_X4_IO_MASK(io);
-			if (currtimings->stop_state_4x) {
-				reg |= ISPCSI2_TIMING_STOP_STATE_X4_IO_ENABLE
-					(io);
-			} else {
-				reg |= ISPCSI2_TIMING_STOP_STATE_X4_IO_DISABLE
-					(io);
-			}
-			currtimings_u->stop_state_4x = false;
-		}
-		if (currtimings_u->stop_state_counter || force_update) {
-			reg &= ~ISPCSI2_TIMING_STOP_STATE_COUNTER_IO_MASK(io);
-			reg |= currtimings->stop_state_counter <<
-				ISPCSI2_TIMING_STOP_STATE_COUNTER_IO_SHIFT(io);
-			currtimings_u->stop_state_counter = false;
-		}
-		isp_reg_writel(isp_csi2->dev, reg, OMAP3_ISP_IOMEM_CSI2A,
-			       ISPCSI2_TIMING);
-		isp_csi2->update_timing = false;
-	}
 	return 0;
 }
 
-/**
- * isp_csi2_timings_get - Gets specific CSI2 ComplexIO timing configuration
- * @io: IO number (1 or 2) which specifies which ComplexIO are we getting
- *
- * Gets settings from HW registers and fills in the internal driver memory
- * Returns 0 if successful, or -EINVAL if invalid IO number is passed.
- **/
-int isp_csi2_timings_get(struct isp_csi2_device *isp_csi2, u8 io)
+static int csi2_configure(struct isp_csi2_device *csi2)
 {
-	struct isp_csi2_timings_cfg *currtimings;
-	struct isp_csi2_timings_cfg_update *currtimings_u;
-	u32 reg;
-
-	if (io < 1 || io > 2) {
-		printk(KERN_ERR "CSI2 - Timings config: Invalid IO number\n");
-		return -EINVAL;
-	}
-
-	currtimings = &isp_csi2->current_cfg.timings[io - 1];
-	currtimings_u = &isp_csi2->current_cfg_update.timings[io - 1];
+	const struct isp_v4l2_subdevs_group *pdata;
+	struct isp_device *isp = csi2->isp;
+	struct isp_csi2_timing_cfg *timing = &csi2->timing[0];
+	struct v4l2_subdev *sensor;
+	struct media_pad *pad;
+
+	/*
+	 * CSI2 fields that can be updated while the context has
+	 * been enabled or the interface has been enabled are not
+	 * updated dynamically currently. So we do not allow to
+	 * reconfigure if either has been enabled
+	 */
+	if (csi2->contexts[0].enabled || csi2->ctrl.if_enable)
+		return -EBUSY;
 
-	reg = isp_reg_readl(isp_csi2->dev, OMAP3_ISP_IOMEM_CSI2A,
-			    ISPCSI2_TIMING);
-	if ((reg & ISPCSI2_TIMING_FORCE_RX_MODE_IO_MASK(io)) ==
-	    ISPCSI2_TIMING_FORCE_RX_MODE_IO_ENABLE(io))
-		currtimings->force_rx_mode = true;
+	pad = media_entity_remote_source(&csi2->pads[CSI2_PAD_SINK]);
+	sensor = media_entity_to_v4l2_subdev(pad->entity);
+	pdata = sensor->host_priv;
+
+	csi2->frame_skip = 0;
+	v4l2_subdev_call(sensor, sensor, g_skip_frames, &csi2->frame_skip);
+
+	csi2->ctrl.vp_out_ctrl = pdata->bus.csi2.vpclk_div;
+	csi2->ctrl.frame_mode = ISP_CSI2_FRAME_IMMEDIATE;
+	csi2->ctrl.ecc_enable = pdata->bus.csi2.crc;
+
+	timing->ionum = 1;
+	timing->force_rx_mode = 1;
+	timing->stop_state_16x = 1;
+	timing->stop_state_4x = 1;
+	timing->stop_state_counter = 0x1FF;
+
+	/*
+	 * The CSI2 receiver can't do any format conversion except DPCM
+	 * decompression, so every set_format call configures both pads
+	 * and enables DPCM decompression as a special case:
+	 */
+	if (csi2->formats[CSI2_PAD_SINK].code !=
+	    csi2->formats[CSI2_PAD_SOURCE].code)
+		csi2->dpcm_decompress = true;
 	else
-		currtimings->force_rx_mode = false;
-	currtimings_u->force_rx_mode = false;
+		csi2->dpcm_decompress = false;
 
-	if ((reg & ISPCSI2_TIMING_STOP_STATE_X16_IO_MASK(io)) ==
-	    ISPCSI2_TIMING_STOP_STATE_X16_IO_ENABLE(io))
-		currtimings->stop_state_16x = true;
-	else
-		currtimings->stop_state_16x = false;
-	currtimings_u->stop_state_16x = false;
+	csi2->contexts[0].format_id = csi2_ctx_map_format(csi2);
 
-	if ((reg & ISPCSI2_TIMING_STOP_STATE_X4_IO_MASK(io)) ==
-	    ISPCSI2_TIMING_STOP_STATE_X4_IO_ENABLE(io))
-		currtimings->stop_state_4x = true;
+	if (csi2->video_out.bpl_padding == 0)
+		csi2->contexts[0].data_offset = 0;
 	else
-		currtimings->stop_state_4x = false;
-	currtimings_u->stop_state_4x = false;
-
-	currtimings->stop_state_counter = (reg &
-					   ISPCSI2_TIMING_STOP_STATE_COUNTER_IO_MASK(io)) >>
-		ISPCSI2_TIMING_STOP_STATE_COUNTER_IO_SHIFT(io);
-	currtimings_u->stop_state_counter = false;
-	isp_csi2->update_timing = false;
+		csi2->contexts[0].data_offset = csi2->video_out.bpl_value;
+
+	/*
+	 * Enable end of frame and end of line signals generation for
+	 * context 0. These signals are generated from CSI2 receiver to
+	 * qualify the last pixel of a frame and the last pixel of a line.
+	 * Without enabling the signals CSI2 receiver writes data to memory
+	 * beyond buffer size and/or data line offset is not handled correctly.
+	 */
+	csi2->contexts[0].eof_enabled = 1;
+	csi2->contexts[0].eol_enabled = 1;
+
+	csi2_irq_complexio1_set(isp, csi2, 1);
+	csi2_irq_ctx_set(isp, csi2, 1);
+	csi2_irq_status_set(isp, csi2, 1);
+
+	/* Set configuration (timings, format and links) */
+	csi2_timing_config(isp, csi2, timing);
+	csi2_recv_config(isp, csi2, &csi2->ctrl);
+	csi2_ctx_config(isp, csi2, &csi2->contexts[0]);
+
 	return 0;
 }
 
-/**
- * isp_csi2_timings_update_all - Applies specified CSI2 timing configuration.
- * @force_update: Flag to force rewrite of registers, even if they haven't been
- *                updated with the isp_csi2_timings_config_*() functions.
- *
- * It only saves settings when they were previously updated using the
- * isp_csi2_timings_config_*() functions, unless the force_update flag is
- * set to true.
- * Always returns 0.
- **/
-int isp_csi2_timings_update_all(struct isp_csi2_device *isp_csi2,
-				bool force_update)
+/*
+ * csi2_print_status - Prints CSI2 debug information.
+ */
+#define CSI2_PRINT_REGISTER(isp, regs, name)\
+	dev_dbg(isp->dev, "###CSI2 " #name "=0x%08x\n", \
+		isp_reg_readl(isp, regs, ISPCSI2_##name))
+
+static void csi2_print_status(struct isp_csi2_device *csi2)
 {
-	int i;
+	struct isp_device *isp = csi2->isp;
+
+	if (!csi2->available)
+		return;
+
+	dev_dbg(isp->dev, "-------------CSI2 Register dump-------------\n");
+
+	CSI2_PRINT_REGISTER(isp, csi2->regs1, SYSCONFIG);
+	CSI2_PRINT_REGISTER(isp, csi2->regs1, SYSSTATUS);
+	CSI2_PRINT_REGISTER(isp, csi2->regs1, IRQENABLE);
+	CSI2_PRINT_REGISTER(isp, csi2->regs1, IRQSTATUS);
+	CSI2_PRINT_REGISTER(isp, csi2->regs1, CTRL);
+	CSI2_PRINT_REGISTER(isp, csi2->regs1, DBG_H);
+	CSI2_PRINT_REGISTER(isp, csi2->regs1, GNQ);
+	CSI2_PRINT_REGISTER(isp, csi2->regs1, PHY_CFG);
+	CSI2_PRINT_REGISTER(isp, csi2->regs1, PHY_IRQSTATUS);
+	CSI2_PRINT_REGISTER(isp, csi2->regs1, SHORT_PACKET);
+	CSI2_PRINT_REGISTER(isp, csi2->regs1, PHY_IRQENABLE);
+	CSI2_PRINT_REGISTER(isp, csi2->regs1, DBG_P);
+	CSI2_PRINT_REGISTER(isp, csi2->regs1, TIMING);
+	CSI2_PRINT_REGISTER(isp, csi2->regs1, CTX_CTRL1(0));
+	CSI2_PRINT_REGISTER(isp, csi2->regs1, CTX_CTRL2(0));
+	CSI2_PRINT_REGISTER(isp, csi2->regs1, CTX_DAT_OFST(0));
+	CSI2_PRINT_REGISTER(isp, csi2->regs1, CTX_DAT_PING_ADDR(0));
+	CSI2_PRINT_REGISTER(isp, csi2->regs1, CTX_DAT_PONG_ADDR(0));
+	CSI2_PRINT_REGISTER(isp, csi2->regs1, CTX_IRQENABLE(0));
+	CSI2_PRINT_REGISTER(isp, csi2->regs1, CTX_IRQSTATUS(0));
+	CSI2_PRINT_REGISTER(isp, csi2->regs1, CTX_CTRL3(0));
+
+	dev_dbg(isp->dev, "--------------------------------------------\n");
+}
 
-	for (i = 1; i < 3; i++)
-		isp_csi2_timings_update(isp_csi2, i, force_update);
-	return 0;
+/* -----------------------------------------------------------------------------
+ * Interrupt handling
+ */
+
+/*
+ * csi2_isr_buffer - Does buffer handling at end-of-frame
+ * when writing to memory.
+ */
+static void csi2_isr_buffer(struct isp_csi2_device *csi2)
+{
+	struct isp_device *isp = csi2->isp;
+	struct isp_buffer *buffer;
+
+	csi2_ctx_enable(isp, csi2, 0, 0);
+
+	buffer = omap3isp_video_buffer_next(&csi2->video_out, 0);
+
+	/*
+	 * Let video queue operation restart engine if there is an underrun
+	 * condition.
+	 */
+	if (buffer == NULL)
+		return;
+
+	csi2_set_outaddr(csi2, buffer->isp_addr);
+	csi2_ctx_enable(isp, csi2, 0, 1);
 }
 
-/**
- * isp_csi2_timings_get_all - Gets all CSI2 ComplexIO timing configurations
- *
- * Always returns 0.
- **/
-int isp_csi2_timings_get_all(struct isp_csi2_device *isp_csi2)
+static void csi2_isr_ctx(struct isp_csi2_device *csi2,
+			 struct isp_csi2_ctx_cfg *ctx)
 {
-	int i;
+	struct isp_device *isp = csi2->isp;
+	unsigned int n = ctx->ctxnum;
+	u32 status;
+
+	status = isp_reg_readl(isp, csi2->regs1, ISPCSI2_CTX_IRQSTATUS(n));
+	isp_reg_writel(isp, status, csi2->regs1, ISPCSI2_CTX_IRQSTATUS(n));
+
+	/* Propagate frame number */
+	if (status & ISPCSI2_CTX_IRQSTATUS_FS_IRQ) {
+		struct isp_pipeline *pipe =
+				     to_isp_pipeline(&csi2->subdev.entity);
+		if (pipe->do_propagation)
+			atomic_inc(&pipe->frame_number);
+	}
+
+	if (!(status & ISPCSI2_CTX_IRQSTATUS_FE_IRQ))
+		return;
+
+	/* Skip interrupts until we reach the frame skip count. The CSI2 will be
+	 * automatically disabled, as the frame skip count has been programmed
+	 * in the CSI2_CTx_CTRL1::COUNT field, so reenable it.
+	 *
+	 * It would have been nice to rely on the FRAME_NUMBER interrupt instead
+	 * but it turned out that the interrupt is only generated when the CSI2
+	 * writes to memory (the CSI2_CTx_CTRL1::COUNT field is decreased
+	 * correctly and reaches 0 when data is forwarded to the video port only
+	 * but no interrupt arrives). Maybe a CSI2 hardware bug.
+	 */
+	if (csi2->frame_skip) {
+		csi2->frame_skip--;
+		if (csi2->frame_skip == 0) {
+			ctx->format_id = csi2_ctx_map_format(csi2);
+			csi2_ctx_config(isp, csi2, ctx);
+			csi2_ctx_enable(isp, csi2, n, 1);
+		}
+		return;
+	}
 
-	for (i = 1; i < 3; i++)
-		isp_csi2_timings_get(isp_csi2, i);
-	return 0;
+	if (csi2->output & CSI2_OUTPUT_MEMORY)
+		csi2_isr_buffer(csi2);
 }
 
-/**
- * isp_csi2_isr - CSI2 interrupt handling.
+/*
+ * omap3isp_csi2_isr - CSI2 interrupt handling.
  *
  * Return -EIO on Transmission error
- **/
-int isp_csi2_isr(struct isp_csi2_device *isp_csi2)
+ */
+int omap3isp_csi2_isr(struct isp_csi2_device *csi2)
 {
+	u32 csi2_irqstatus, cpxio1_irqstatus;
+	struct isp_device *isp = csi2->isp;
 	int retval = 0;
-	u32 csi2_irqstatus, cpxio1_irqstatus, ctxirqstatus;
 
-	csi2_irqstatus = isp_reg_readl(isp_csi2->dev,
-				       OMAP3_ISP_IOMEM_CSI2A,
-				       ISPCSI2_IRQSTATUS);
-	isp_reg_writel(isp_csi2->dev, csi2_irqstatus,
-		       OMAP3_ISP_IOMEM_CSI2A, ISPCSI2_IRQSTATUS);
+	if (!csi2->available)
+		return -ENODEV;
+
+	csi2_irqstatus = isp_reg_readl(isp, csi2->regs1, ISPCSI2_IRQSTATUS);
+	isp_reg_writel(isp, csi2_irqstatus, csi2->regs1, ISPCSI2_IRQSTATUS);
 
 	/* Failure Cases */
 	if (csi2_irqstatus & ISPCSI2_IRQSTATUS_COMPLEXIO1_ERR_IRQ) {
-		cpxio1_irqstatus = isp_reg_readl(isp_csi2->dev,
-						 OMAP3_ISP_IOMEM_CSI2A,
-						 ISPCSI2_COMPLEXIO1_IRQSTATUS);
-		isp_reg_writel(isp_csi2->dev, cpxio1_irqstatus,
-			       OMAP3_ISP_IOMEM_CSI2A,
-			       ISPCSI2_COMPLEXIO1_IRQSTATUS);
-		dev_dbg(isp_csi2->dev, "CSI2: ComplexIO Error IRQ %x\n",
-			cpxio1_irqstatus);
+		cpxio1_irqstatus = isp_reg_readl(isp, csi2->regs1,
+						 ISPCSI2_PHY_IRQSTATUS);
+		isp_reg_writel(isp, cpxio1_irqstatus,
+			       csi2->regs1, ISPCSI2_PHY_IRQSTATUS);
+		dev_dbg(isp->dev, "CSI2: ComplexIO Error IRQ "
+			"%x\n", cpxio1_irqstatus);
 		retval = -EIO;
 	}
 
